<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Population Globe with Zoom</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: #000;

      font-family: -apple-system, BlinkMacSystemFont,
                   "Segoe UI", Roboto,
                   "Helvetica Neue", Arial,
                   sans-serif;

      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    canvas { display: block; }
    #searchContainer {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 340px;
      z-index: 10;
    }

    #citySearch {
      width: 100%;
      padding: 12px 20px;
      border-radius: 40px;
      border: 1.5px solid rgba(255, 255, 255, 0.9);
      outline: none;
      background: #000;
      color: #fff;
      font-size: 15px;
      letter-spacing: 0.5px;
      box-shadow: 0 0 18px rgba(255,255,255,0.06);
      transition: border 0.2s ease, box-shadow 0.2s ease;
    }

    #citySearch:focus {
      border: 1.5px solid #ffffff;
      box-shadow: 0 0 12px rgba(255,255,255,0.4);
    }

    #searchResults {
      margin-top: 8px;
      background: rgba(0,0,0,0.96);
      border-radius: 14px;
      max-height: 210px; /* ~5 results */
      overflow-y: auto;
      display: none;
      box-shadow: 0 0 15px rgba(255,255,255,0.04);
    }

   .searchItem {
      padding: 10px 14px;
      cursor: pointer;
      color: #fff;
      font-size: 14px;
    }

    .searchItem:hover {
      background: rgba(255,255,255,0.08);
    }

    #cityList {
      display: none;
      position: absolute; top: 5px; right: -500px; width: 250px; max-height: 85vh; overflow-y: auto;
      background: rgba(0,0,0,0.75); color: #fff; padding: 8px; font-size: 10px; border-radius: 8px;
    }
    #cityList ul { list-style: none; padding: 0; margin: 0; }
    #cityList li { margin-bottom: 5px; border-bottom: 1px solid rgba(255,255,255,0.08); padding-bottom: 3px; }
    #cityList li:last-child { border-bottom: none; }
    #infoPanel {
      position: fixed;
      bottom: -100%;
      left: 0;
      width: 100%;
      height: 420px;

      background: rgba(0,0,0,0.95);
      color: white;

      padding: 20px;
      box-sizing: border-box;

      transition: bottom 0.4s ease;

      overflow: hidden;
      display: flex;
      flex-direction: column;

      border-top: 2px solid rgba(255,255,255,0.1);

      scroll-behavior: smooth;

      backdrop-filter: blur(16px);
    }

     .panelHeader {
      position: sticky;
      top: 0;

      display: flex;
      justify-content: space-between;
      align-items: center;

      padding-bottom: 10px;
      margin-bottom: 8px;

      background: rgba(0,0,0,0.95);
      backdrop-filter: blur(16px);

      z-index: 5;
    }

    .panelHeader h2 {
      margin: 0;
    }

    .panelHeader h4 {
      margin: 2px 0 0 0;
      opacity: 0.7;
    }

    .paginationBar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .dots {
      display: flex;
      gap: 8px;
    }

    .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: rgba(120,120,120,0.6);
      transition: all 0.25s ease;
      cursor: pointer;
    }

    .dot.active {
      background: rgba(255,180,80,1);
      box-shadow: 0 0 8px rgba(255,150,40,0.7);
    }

    .pageJump {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      opacity: 0.7;
    }

    .pageJump input {
      width: 45px;
      background: rgba(50,50,50,0.8);
      border: none;
      color: white;
      padding: 4px;
      border-radius: 6px;
      text-align: center;
    }

    .articlesViewport {
      flex: 1;
      overflow: hidden;
      position: relative;
    }

    .articlesTrack {
      display: flex;
      height: 100%;
      transition: transform 0.35s ease;
    }

    .articlePage {
      min-width: 100%;
      padding-right: 10px;
      box-sizing: border-box;
      overflow-y: auto;
    }      

   


    #infoPanel.active { bottom: 0; }
    #infoPanel a { color: #4da6ff; text-decoration: none; display: block; margin-bottom: 8px; }
    #infoPanel a:hover { text-decoration: underline; }

    /* ===============================
       Electric Glass Scrollbar
    =============================== */

    #infoPanel::-webkit-scrollbar {
      width: 8px;
    }

    #infoPanel::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.03);
      border-radius: 12px;
      backdrop-filter: blur(10px);
    }

    #infoPanel::-webkit-scrollbar-thumb {
      background: linear-gradient(
        180deg,
        rgba(255,255,255,0.35),
        rgba(120,180,255,0.25)
      );
      border-radius: 12px;

      box-shadow:
        0 0 6px rgba(255,255,255,0.15),
        0 0 10px rgba(0,150,255,0.15);

      transition:
        background 0.3s ease,
        box-shadow 0.3s ease,
        transform 0.2s ease;
    }

    #infoPanel::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(
        180deg,
        rgba(255,255,255,0.6),
        rgba(0,150,255,0.4)
      );

      box-shadow:
        0 0 12px rgba(255,255,255,0.35),
        0 0 20px rgba(0,150,255,0.45);

      transform: scaleX(1.1);
    }

    /* Firefox */

    #infoPanel {
      scrollbar-width: thin;
      scrollbar-color:
        rgba(200,220,255,0.6)
        rgba(255,255,255,0.04);
    }


    #infoPanel button.closePanel {
      position: absolute;
      top: 10px;
      right: 15px;
      background: #444;
      color: #fff;
      border: none;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 12px;
      border-radius: 4px;
    }
    #infoPanel button.closePanel:hover {
       background: #666;
    }

    .cityBubble {
      position: absolute;
      pointer-events: none;
      transform: translate(-50%, -140%);
      transition: opacity 0.2s ease, transform 0.2s ease;
      font-size: 11px;
      color: #fff;
      white-space: nowrap;
    }

    .bubbleContent {
      background: rgba(0, 0, 0, 0.88);
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 6px 10px;
      border-radius: 10px;
      backdrop-filter: blur(6px);
      box-shadow: 0 0 12px rgba(0, 0, 0, 0.5);
    }

    .bubbleTitle {
      font-weight: 600;
      font-size: 12px;
      margin-bottom: 2px;
    }

    .bubbleMeta {
      font-size: 10px;
      opacity: 0.7;
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .bubbleWrapper {
      position: relative;
      display: inline-block;
    }

    .bubbleOutline {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .bubbleRect {
      fill: rgba(0, 0, 0, 0.88);
      stroke: rgba(255, 255, 255, 0.4);
      stroke-width: 1.2;
    }

    .bubbleContent {
      position: relative;
      padding: 6px 12px;
      border-radius: 12px;
      color: #fff;
      white-space: nowrap;
    }

    .cityBubble.hovered .bubbleContent {
      animation: bubblePulse 11s ease-in-out infinite;
    }

    @keyframes electricPulse {
      0% {
        box-shadow:
          0 0 6px rgba(255,255,255,0.08),
          0 0 0px rgba(0,150,255,0);
      }
      35% {
        box-shadow:
          0 0 18px rgba(255,255,255,0.35),
          0 0 28px rgba(0,150,255,0.6);
      }
      70% {
        box-shadow:
          0 0 10px rgba(255,255,255,0.2),
          0 0 14px rgba(0,150,255,0.3);
      }
      100% {
        box-shadow:
          0 0 6px rgba(255,255,255,0.08),
          0 0 0px rgba(0,150,255,0);
      }
    }


/* ===============================
   Compass
=============================== */

#compass {

  position: absolute;
  top: 20px;
  right: 20px;

  width: 56px;
  height: 56px;

  border-radius: 50%;

  backdrop-filter: blur(12px);
  background: rgba(0, 0, 0, 0.65);
  border: 1px solid rgba(255,255,255,0.25);

  display: flex;
  align-items: center;
  justify-content: center;

  cursor: pointer;
  user-select: none;

  z-index: 30;

  transition: transform 0.2s ease;
}

#compass:hover {
  transform: scale(1.08);
}

.compass-svg {
  width: 100%;
  height: 100%;
}

.compass-circle {
  fill: none;
  stroke: rgba(255,255,255,0.5);
  stroke-width: 2;
}

.compass-letter {
  fill: white;
  font-size: 12px;
  font-weight: 600;
  opacity: 0.9;
}

.compass-arrow-line {
  stroke: white;
  stroke-width: 2;
}

.compass-arrow-head {
  fill: red;
}

.compass-tick {
  stroke: rgba(255,255,255,0.6);
  stroke-width: 1;
}

.compass-tick.major {
  stroke-width: 2;
}

#modeWidget {
  position: absolute;
  top: 90px;
  right: 20px;
  width: 140px;
  border-radius: 16px;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(12px);
  border: 1px solid rgba(255,255,255,0.2);
  color: white;
  z-index: 30;
  overflow: hidden;
  transition: height 0.3s ease, width 0.3s ease;
}

#modeWidget.minimized {
  height: 40px;
  width: 70px;
}

#modeHeader {
  padding: 10px;
  font-weight: 600;
  cursor: pointer;
}

#modeOptions {
  display: flex;
  flex-direction: column;
  padding: 8px;
  gap: 6px;
}

#modeOptions button {
  background: rgba(255,255,255,0.08);
  border: none;
  color: white;
  padding: 6px;
  border-radius: 10px;
  cursor: pointer;
}

#modeOptions button.active {
  background: rgba(255,255,255,0.25);
}

#ambientControl {
  position: absolute;
  bottom: 20px;
  left: 20px;
  width: 180px;
  padding: 10px;
  border-radius: 14px;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(12px);
  border: 1px solid rgba(255,255,255,0.2);
  color: white;
  z-index: 30;
  font-size: 12px;
}

#ambientControl input {
  width: 100%;
  margin-top: 6px;
}






  </style>
</head>

<body>
  <div id="cityList"><h3>Geopolitical Cities</h3><ul id="list"></ul></div>
  <div id="infoPanel"><div id="panelContent"></div></div>
  <div id="cityLabels" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;"></div>
  <svg id="uiOverlay"
       style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:5;">
    <line id="hoverLine"
        stroke="white"
        stroke-width="1"
        opacity="0"/>
  </svg>
  <div id="searchContainer">
    <input type="text" id="citySearch" placeholder="Search city..." />
    <div id="searchResults"></div>
  </div>

<!-- Compass Widget -->
<div id="compass">
  <svg class="compass-svg" viewBox="0 0 100 100">
    
    <!-- Outer Ring -->
    <circle cx="50" cy="50" r="46" class="compass-circle" />

    <!-- Tick Marks -->
    <g class="compass-ticks"></g>

    <!-- Cardinal Letters -->
    <text x="50" y="18" text-anchor="middle" class="compass-letter">N</text>
    <text x="50" y="92" text-anchor="middle" class="compass-letter">S</text>
    <text x="8" y="54" text-anchor="middle" class="compass-letter">W</text>
    <text x="92" y="54" text-anchor="middle" class="compass-letter">E</text>

<!-- Arrow — wrapped in group so only needle rotates, not the N/S/E/W labels -->
    <g class="compass-arrow-group">
      <line x1="50" y1="50" x2="50" y2="25" class="compass-arrow-line"/>
      <polygon points="50,15 45,25 55,25" class="compass-arrow-head"/>
    </g>

  </svg>
</div>

<div id="modeWidget" class="expanded">
  <div id="modeHeader">View</div>
  <div id="modeOptions">
    <button id="cityModeBtn">City</button>
    <button id="countryModeBtn" class="active">Country</button>
  </div>
</div>

<div id="ambientControl">
  <label>Ambient Rotation</label>
  <input type="range"
         id="ambientSlider"
         min="0"
         max="0.0015"
         step="0.00005"
         value="0.00015" />
</div>






  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js";

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 3;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);


    const maxTilt = Math.PI / 2.2;

          // ===============================
      // Window Resize Handling
      // ===============================

      window.addEventListener("resize", () => {

        const width = window.innerWidth;
        const height = window.innerHeight;

        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

      });


    const radius = 1;

    // Smooth zoom target
    let targetZoom = camera.position.z;
    let zoomVelocity = 0;
    const zoomFriction = 0.92;

    let yawVelocity = 0;
    let tiltVelocity = 0;
    let globeQuat = new THREE.Quaternion();  // FIX #3: single quaternion replaces yaw/pitch
    let ambientSpeed = 0.001;
    let ambientEnabled = true;
    let ambientPaused = false;
    let ambientResumeTimer = null;

    // FIX #3: quaternion delta helpers — no euler accumulation, no gimbal lock
    function applyYaw(rad) {
      globeQuat.premultiply(
        new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), rad)
      );
    }

    function applyTilt(rad) {
      const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
      globeQuat.premultiply(
        new THREE.Quaternion().setFromAxisAngle(right, rad)
      );
    }

    function pauseAmbientRotation() {
      ambientPaused = true;
      if (ambientResumeTimer) {
        clearTimeout(ambientResumeTimer);
      }
      // Resume after 8 seconds of inactivity
      ambientResumeTimer = setTimeout(() => {
        ambientPaused = false;
      }, 1000);
    }

    // Hard lock on node selection — stays frozen until panel closes
    function lockAmbientRotation() {
      ambientPaused = true;
      if (ambientResumeTimer) {
        clearTimeout(ambientResumeTimer);
        ambientResumeTimer = null;
      }
    }

    // Deferred resume — called when panel closes
    function scheduleAmbientResume() {
      if (ambientResumeTimer) clearTimeout(ambientResumeTimer);
      ambientResumeTimer = setTimeout(() => {
        ambientPaused = false;
      }, 8000);
    }


    /* ===============================
       Load Earth texture and initialize
    =============================== */
    const loader = new THREE.TextureLoader();
    const earthTexture = loader.load(
      "https://threejs.org/examples/textures/land_ocean_ice_cloud_2048.jpg",
      () => {

        Promise.all([
          fetch("https://earth-wjr6.onrender.com/api/cities")
            .then(res => res.json()),
          fetch("https://earth-wjr6.onrender.com/api/countries")
            .then(res => res.json())
        ])
          .then(([cities, countries]) => {
            init(cities, countries);
          })
          .catch(err => {
            console.error("Failed to load initial data:", err);
          });

      }
    );



    function init(cities, countries) {
      // Earth points
      const earthPointCount = 10000;
      const earthPositions = [];
      const earthColors = [];
      const earthBaseBrightness = [];

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = earthTexture.image.width;
      canvas.height = earthTexture.image.height;
      ctx.drawImage(earthTexture.image, 0, 0);
      const imageData = ctx.getImageData(0,0,canvas.width,canvas.height).data;

      for(let i=0;i<earthPointCount;i++){
        const u=Math.random(), v=Math.random();
        const theta = 2*Math.PI*u;
        const phi = Math.acos(2*v-1);
        const x = radius*Math.sin(phi)*Math.cos(theta);
        const y = radius*Math.cos(phi);
        const z = radius*Math.sin(phi)*Math.sin(theta);
        earthPositions.push(x,y,z);
        const lon=Math.atan2(z,x), lat=Math.asin(y/radius);
        const uTex=(lon/(2*Math.PI))+0.5;
        const vTex=0.5-(lat/Math.PI);
        const px = Math.floor(uTex*canvas.width), py = Math.floor(vTex*canvas.height);
        const idx=(py*canvas.width+px)*4;
        const r=imageData[idx], g=imageData[idx+1], b=imageData[idx+2];
        const bright = (r+g+b)/3;
        const c = bright>120 ? 0.2 : 1.0;
        earthColors.push(c,c,c);
        earthBaseBrightness.push(c);
      }

      const earthGeo = new THREE.BufferGeometry();
      earthGeo.setAttribute("position", new THREE.Float32BufferAttribute(earthPositions,3));
      earthGeo.setAttribute("color", new THREE.Float32BufferAttribute(earthColors,3));
      const earthMat = new THREE.PointsMaterial({ size:0.006, vertexColors:true, transparent:true, depthWrite:false });
      const earthPoints = new THREE.Points(earthGeo, earthMat);
      scene.add(earthPoints);

            // ------------------------------
      // Earth Twinkle System
      // ------------------------------

      const earthTwinkleChance = 0.04;
      const earthTwinkleDuration = 0.2;
      const earthTwinkleIntensity = 0.6;

      const earthTwinkleTimers = new Array(earthPointCount).fill(0);


      /* ===============================
         FULL CITY LIST GOES HERE
      =============================== */


      // City points
      const citySize = 0.0375;
      const ringBurstDelay = 0.18;
      const ringSpeed = 0.008; 
      const positions = [];
      const ringMultiplierMax = 8;
      const ringStartRadius = 0.005;
      const ringThickness = 0.0001;
      const ringOuterMultiplier = 8;
      const listElement = document.getElementById("list");
      cities.forEach(city=>{
        const {name,lat,lon,country}=city;
        const phi=(90-lat)*(Math.PI/180);
        const theta=(lon+180)*(Math.PI/180);
        const x=-radius*Math.sin(phi)*Math.cos(theta);
        const z= radius*Math.sin(phi)*Math.sin(theta);
        const y= radius*Math.cos(phi);
        positions.push(x,y,z);
        const li=document.createElement("li");
        li.textContent = (country && name !== country)
          ? `${name}, ${country}`
          : name;
        listElement.appendChild(li);
      });

      const cityGeo=new THREE.BufferGeometry();
      cityGeo.setAttribute("position", new THREE.Float32BufferAttribute(positions,3));

      function createGlowTexture(){
        const size=128;
        const glowCanvas=document.createElement("canvas");
        glowCanvas.width=size; glowCanvas.height=size;
        const ctx=glowCanvas.getContext("2d");
        const outerRadius = size * 0.15;
        const grad=ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
        grad.addColorStop(0,"rgba(255,200,120,1)");
        grad.addColorStop(0.4,"rgba(255,140,40,0.7)");
        grad.addColorStop(0.8,"rgba(255,80,20,0.3)");
        grad.addColorStop(1,"rgba(255,80,20,0)");
        ctx.fillStyle=grad; ctx.fillRect(0,0,size,size);
        return new THREE.CanvasTexture(glowCanvas);
      }

      const glowTexture=createGlowTexture();
      const cityMat=new THREE.PointsMaterial({
        size:citySize,
        sizeAttenuation: true,
        map:glowTexture,
        transparent:true,
        blending:THREE.AdditiveBlending,
        depthWrite:false
      });
      const cityPoints=new THREE.Points(cityGeo,cityMat);
      scene.add(cityPoints);

            // ===============================
      // Country Points
      // ===============================

      const countryPositions = [];

      countries.forEach(country => {

        const { lat, lon } = country;

        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);

        const x = -radius * Math.sin(phi) * Math.cos(theta);
        const z =  radius * Math.sin(phi) * Math.sin(theta);
        const y =  radius * Math.cos(phi);

        countryPositions.push(x, y, z);
      });

      const countryGeo = new THREE.BufferGeometry();
      countryGeo.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(countryPositions, 3)
      );

      const countryMat = new THREE.PointsMaterial({
        size: citySize * 1.6,
        sizeAttenuation: true,
        map: glowTexture,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        opacity: 1
      });

      const countryPoints = new THREE.Points(countryGeo, countryMat);
      scene.add(countryPoints);


            // ===============================
      // Selection Ring Burst
      // ===============================


      const ringGroup = new THREE.Group();
      scene.add(ringGroup);

      const ringCount = 3;
      const ringMeshes = [];
      const ringStates = [];

      for (let i = 0; i < ringCount; i++) {

        const ringGeo = new THREE.RingGeometry(
          ringStartRadius,
          ringStartRadius + ringThickness * ringOuterMultiplier,
          64
        );


        const ringMat = new THREE.MeshBasicMaterial({
          color: new THREE.Color(1.0, 0.6, 0.25),
          transparent: true,
          opacity: 0,
          side: THREE.DoubleSide,
          depthWrite: false,
          blending: THREE.NormalBlending
        });


        const ring = new THREE.Mesh(ringGeo, ringMat);


        ringGroup.add(ring);
        ringMeshes.push(ring);

        ringStates.push({
          progress: 0,
          delay: i * ringBurstDelay,
          active: false
        });
      }
     

      /* >>>>> INSERTED: GEO BOUNDARY LOADER START */

      const boundaryLayer = new GeoBoundaryLayer(scene, radius);

      fetch("custom.geo.json")
        .then(res => res.json())
        .then(data => {
          boundaryLayer.loadGeoJSON(data);
        });

      // ------------------------------
      // Utility: check if city is facing the camera
      // ------------------------------

      function isCityVisible(pointPos, camera) {
 
        const pointVector = pointPos.clone().normalize();


        const cameraDir = new THREE.Vector3();
        camera.getWorldDirection(cameraDir).normalize();

        const dot = cameraDir.dot(pointVector);
        return dot < 0;
      }

      // FIX #1: True-north compass
      // Projects the globe's north pole into camera screen space and rotates
      // only the needle group — N/S/E/W labels stay fixed.
      function updateCompass() {

        const arrowGroup = document.querySelector(".compass-arrow-group");
        if (!arrowGroup) return;

        const northWorld = new THREE.Vector3(0, 1, 0)
          .applyQuaternion(scene.quaternion);

        const northNDC = northWorld.clone().project(camera);

        // atan2(dx, dy) = clockwise angle from screen-up to projected north
        const angle = Math.atan2(northNDC.x, northNDC.y);

        arrowGroup.setAttribute(
          "transform",
          `rotate(${angle * 180 / Math.PI}, 50, 50)`
        );
      }      


      function updateNodeGlow() {

        const activePoints = currentViewMode === "country"
          ? countryPoints
          : cityPoints;

        const activeMaterial = currentViewMode === "country"
          ? countryMat
          : cityMat;

        const cameraDir = new THREE.Vector3();
        camera.getWorldDirection(cameraDir).normalize();

        const positionsAttr =
          activePoints.geometry.attributes.position;

        const count = positionsAttr.count;

        if (!activePoints.geometry.attributes.color) {

          const colors = new Float32Array(count * 3);

          activePoints.geometry.setAttribute(
            "color",
            new THREE.BufferAttribute(colors, 3)
          );

          activeMaterial.vertexColors = true;

        }

        const colors =
          activePoints.geometry.attributes.color;

        for (let i = 0; i < count; i++) {

          const nodePos = new THREE.Vector3();

          nodePos.fromBufferAttribute(positionsAttr, i);
          nodePos.applyMatrix4(activePoints.matrixWorld);
          nodePos.normalize();

          let dot = -cameraDir.dot(nodePos);
          let normalized = (dot + 1) / 2;

          const minGlow = 0.15;

          let glow =
            minGlow +
            (1 - minGlow) * Math.pow(normalized, 2.5);

          if (glowPulseActive && i === selectedNodeIndex) {
            const pulse =
              1 + 0.4 * Math.sin(glowPulseTime * Math.PI);
            glow *= pulse;
          }

          colors.setXYZ(
            i,
            glow,
            glow * 0.6,
            glow * 0.25
          );

        }

        colors.needsUpdate = true;

      }



      const cityLabelsContainer = document.getElementById("cityLabels");
      const cityLabels = cities.map(city => {

        const div = document.createElement("div");

        div.innerHTML = `
          <div class="bubbleWrapper">

            <svg class="bubbleOutline">
              <rect class="bubbleRect"
                    x="0"
                    y="0"
                    rx="12"
                    ry="12"
                    width="100%"
                    height="100%" />
            </svg>

            <div class="bubbleContent">
              <div class="bubbleTitle">${city.name}</div>
              <div class="bubbleMeta">
                <span class="storyCount">0 stories</span>
              </div>
            </div>

          </div>
        `;


        div.className = "cityBubble";
        div.style.position = "absolute";
        div.style.pointerEvents = "none";
        div.style.opacity = 0;
        div.style.transition = "opacity 0.2s";

        cityLabelsContainer.appendChild(div);

        return div;
      });

      
      const countryLabels = countries.map(country => {

        const div = document.createElement("div");

        div.innerHTML = `
          <div class="bubbleWrapper">

            <svg class="bubbleOutline">
              <rect class="bubbleRect"
                    x="0"
                    y="0"
                    rx="12"
                    ry="12"
                    width="100%"
                    height="100%" />
            </svg>

            <div class="bubbleContent">
              <div class="bubbleTitle">${country.name}</div>
              <div class="bubbleMeta">
                <span class="storyCount">0 stories</span>
              </div>
            </div>

          </div>
        `;

        div.className = "cityBubble";
        div.style.position = "absolute";
        div.style.pointerEvents = "none";
        div.style.opacity = 0;
        div.style.transition = "opacity 0.2s";

        cityLabelsContainer.appendChild(div);

        return div;

      });

      

      

      let hoveredIndex = null;
      let selectedNodeIndex = null;
      let isFocused = false;
      let focusTargetQuat = null;   // FIX #2: target quaternion we slerp toward
      let hoveredCityPosition = null;
      let timeInterval = null;
      let dragging = false;
      let prevX = 0;
      let prevY = 0;

      // ===============================
      // Drag Rotation (Yaw / Pitch System)
      // ===============================

      window.addEventListener("mousedown", e => {

        pauseAmbientRotation();

        dragging = true;
        prevX = e.clientX;
        prevY = e.clientY;

        selectedNodeIndex = null;
        isFocused = false;

      });

      window.addEventListener("mouseup", () => {

        dragging = false;

      });

      window.addEventListener("mousemove", e => {
        if (!dragging) return;
        const deltaX = (e.clientX - prevX) * 0.005;
        const deltaY = (e.clientY - prevY) * 0.005;
        applyYaw(deltaX);
        applyTilt(-deltaY);
        prevX = e.clientX;
        prevY = e.clientY;
      });



      // ===============================
      // VIEW MODE TOGGLE
      // ===============================

      let currentViewMode = "country";
      setActiveMode("country");

      cityMat.opacity = 0.15;
      countryMat.opacity = 1.0;

      const ambientSlider = document.getElementById("ambientSlider");

      if (ambientSlider) {
        ambientSlider.addEventListener("input", () => {
        ambientSpeed = parseFloat(ambientSlider.value);
        });
      }


      

      const widget = document.getElementById("modeWidget");
      const header = document.getElementById("modeHeader");

      header.addEventListener("click", () => {
        widget.classList.toggle("minimized");
      });

      document.getElementById("cityModeBtn").addEventListener("click", () => {

        currentViewMode = "city";
        setActiveMode("city");

        targetCityOpacity = 1.0;
        targetCountryOpacity = 0.15;

      });

      document.getElementById("countryModeBtn").addEventListener("click", () => {

        currentViewMode = "country";
        setActiveMode("country");

        targetCityOpacity = 0.15;
        targetCountryOpacity = 1.0;

      });

      function setActiveMode(mode) {

        document.getElementById("cityModeBtn").classList.remove("active");
        document.getElementById("countryModeBtn").classList.remove("active");

        if (mode === "city") {
          document.getElementById("cityModeBtn").classList.add("active");
        } else {
          document.getElementById("countryModeBtn").classList.add("active");
        }

      }      

      



      let glowPulseTime = 0;
      let glowPulseActive = false;

      const compass = document.getElementById("compass");

      compass.addEventListener("click", () => {

        // Extract current yaw, rebuild globeQuat with zero tilt
        const currentEuler = new THREE.Euler()
          .setFromQuaternion(globeQuat, "YXZ");

        globeQuat.setFromEuler(
          new THREE.Euler(0, currentEuler.y, 0, "YXZ")
        );

        isFocused = false;
        focusTargetQuat = null;
        selectedNodeIndex = null;

      });

      const hoverMouse = new THREE.Vector2();


      window.addEventListener("mousemove", (event) => {
          hoverMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          hoverMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      });

      function updateHoverLabels() {

        raycaster.setFromCamera(hoverMouse, camera);

        const activePoints = currentViewMode === "country"
          ? countryPoints
          : cityPoints;

        const activeData = currentViewMode === "country"
          ? countries
          : cities;

        const activeLabels = currentViewMode === "country"
          ? countryLabels
          : cityLabels;

        const activePositions = currentViewMode === "country"
          ? countryPositions
          : positions;

        const intersects = raycaster.intersectObject(activePoints);

        hoveredIndex = null;
        hoveredCityPosition = null;

        const infoPanel = document.getElementById("infoPanel");
        const panelOpen = infoPanel.classList.contains("active");

        // ------------------------------
        // Hover Detection
        // ------------------------------

        if (intersects.length > 0) {

          const index = intersects[0].index;

          if (panelOpen && index === selectedNodeIndex) {
            return;
          }

          const nodePos = new THREE.Vector3();

          nodePos.fromBufferAttribute(
            activePoints.geometry.attributes.position,
            index
          );

          nodePos.applyMatrix4(activePoints.matrixWorld);

          if (isCityVisible(nodePos, camera)) {

            hoveredIndex = index;
            hoveredCityPosition = nodePos.clone();

          }

        }

        // ------------------------------
        // Label Rendering
        // ------------------------------

        activeData.forEach((item, i) => {

          const label = activeLabels[i];
          if (!label) return;

          const pos = new THREE.Vector3(
            activePositions[i * 3],
            activePositions[i * 3 + 1],
            activePositions[i * 3 + 2]
          );

          pos.applyMatrix4(activePoints.matrixWorld);

          const projected = pos.clone().project(camera);

          const x = (projected.x + 1) / 2 * window.innerWidth;
          const y = (-projected.y + 1) / 2 * window.innerHeight;

          label.style.left = `${x}px`;
          label.style.top  = `${y}px`;

          const isHovered  = (i === hoveredIndex);
          const isSelected = (i === selectedNodeIndex);

          const shouldShow =
            (isHovered) ||
            (!panelOpen && isSelected);

          if (isSelected) {
            label.classList.add("focused");
          } else {
            label.classList.remove("focused");
          }

          if (isHovered) {
            label.classList.add("hovered");
          } else {
            label.classList.remove("hovered");
          }

          if (shouldShow) {

            const storyCountEl = label.querySelector(".storyCount");

            if (storyCountEl) {
              storyCountEl.textContent =
                `${item.storyCount || 0} stories`;
            }

            label.style.opacity = 1;
            label.style.transform =
              "translate(-50%, -160%) scale(1)";

            if (isHovered || isSelected) {
              triggerBubbleTyping(i);
            }

          } else {

            label.style.opacity = 0;
            label.style.transform =
              "translate(-50%, -140%) scale(0.95)";

            const title = label.querySelector(".bubbleTitle");

            if (title) {

              title._typingActive = false;

              if (title._typingTimer) {
                clearTimeout(title._typingTimer);
                title._typingTimer = null;
              }

              title.textContent = item.name;
            }

          }

        });

      }


            // ------------------------------
      // Bubble Perimeter Trace
      // ------------------------------

      function triggerBubbleTrace(index, onComplete) {

        const activeLabels = currentViewMode === "country"
          ? countryLabels
          : cityLabels;

        const bubble = activeLabels[index];
        if (!bubble) return;

        const content = bubble.querySelector(".bubbleContent");
        if (!content) return;

        content.classList.remove("trace");
        void content.offsetWidth; // force reflow to restart animation
        content.classList.add("trace");

        setTimeout(() => {

          if (onComplete) {
            onComplete();
          }

        }, 500);

      }


      

      function triggerBubbleTyping(index) {

        const activeData = currentViewMode === "country"
          ? countries
          : cities;

        const activeLabels = currentViewMode === "country"
          ? countryLabels
          : cityLabels;

        const bubble = activeLabels[index];
        if (!bubble) return;

        const title = bubble.querySelector(".bubbleTitle");
        if (!title) return;

        const fullText = activeData[index].name;

        if (title.textContent === fullText) return;
        if (title._typingActive) return;

        if (title._typingTimer) {
          clearTimeout(title._typingTimer);
          title._typingTimer = null;
        }

        title.textContent = "";
        title._typingActive = true;
        title.classList.add("typing");

        let charIndex = 0;
        const typingSpeed = 22.5;

        function type() {

          if (charIndex < fullText.length) {

            title.textContent += fullText.charAt(charIndex);
            charIndex++;

            title._typingTimer = setTimeout(type, typingSpeed);

          } else {

            title._typingActive = false;
            title._typingTimer = null;
            title.classList.remove("typing");

          }

        }

        type();

      }



      // ------------------------------
      // Electric Bubble Timer
      // ------------------------------

      function triggerElectricPulse() {

        const activeLabels = currentViewMode === "country"
          ? countryLabels
          : cityLabels;

        activeLabels.forEach(label => {

          if (label.style.opacity === "1") {

            label.classList.remove("electric");
            void label.offsetWidth;
            label.classList.add("electric");

          }

        });

      }


      setInterval(() => {

        triggerElectricPulse();

      }, 3000);




      // Raycaster for node clicks

      const raycaster=new THREE.Raycaster();
      raycaster.params.Points.threshold=0.02;
      const mouse=new THREE.Vector2();

      window.addEventListener("click",event=>{

        mouse.x=(event.clientX/window.innerWidth)*2-1;
        mouse.y=-(event.clientY/window.innerHeight)*2+1;

        raycaster.setFromCamera(mouse,camera);

        const activePoints = currentViewMode === "country"
          ? countryPoints
          : cityPoints;

        const activeData = currentViewMode === "country"
          ? countries
          : cities;

        const intersects=raycaster.intersectObject(activePoints);

        if(intersects.length>0){

          const index=intersects[0].index;

          const nodePos = new THREE.Vector3();
          nodePos.fromBufferAttribute(
            activePoints.geometry.attributes.position,
            index
          );
          nodePos.applyMatrix4(activePoints.matrixWorld);

          if (isCityVisible(nodePos, camera)) {

            lockAmbientRotation();    

            selectedNodeIndex = index;
            isFocused = true;

            if (currentViewMode === "country") {

              focusCountry(activeData[index]);
              openCountryPanel(activeData[index]);

            } else {

              focusCity(activeData[index]);
              openCityPanel(activeData[index]);

            }

          }

        }

      });

      
      


      /* ===============================
         iOS TOUCH NODE SELECTION
      =============================== */

      window.addEventListener("touchstart", (event) => {

        if (event.touches.length !== 1) return;

        const touch = event.touches[0];

        mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        const activePoints = currentViewMode === "country"
          ? countryPoints
          : cityPoints;

        const activeData = currentViewMode === "country"
          ? countries
          : cities;

        const intersects = raycaster.intersectObject(activePoints);

        if (intersects.length > 0) {

          const index = intersects[0].index;

          const nodePos = new THREE.Vector3();
          nodePos.fromBufferAttribute(
            activePoints.geometry.attributes.position,
            index
          );
          nodePos.applyMatrix4(activePoints.matrixWorld);

          if (isCityVisible(nodePos, camera)) {
            lockAmbientRotation();    

            selectedNodeIndex = index;
            isFocused = true;

            if (currentViewMode === "country") {

              focusCountry(activeData[index]);
              openCountryPanel(activeData[index]);

            } else {

              focusCity(activeData[index]);
              openCityPanel(activeData[index]);

            }

          }

        }

      }, { passive: true });


            // ------------------------------
      // Leader Line Helpers
      // ------------------------------

      // ------------------------------
      // Leader Line Helpers
      // ------------------------------

      function updateHoverLine(x, y) {

        const line = document.getElementById("hoverLine");
        if (!line) return;

        if (hoveredIndex === null) {

          line.style.opacity = "0";
          return;

        }

        const activeLabels = currentViewMode === "country"
          ? countryLabels
          : cityLabels;

        const bubble = activeLabels[hoveredIndex];

        if (!bubble) {

          line.style.opacity = "0";
          return;

        }


        const rect = bubble.getBoundingClientRect();

        const bubbleX = rect.left + rect.width / 2;
        const bubbleY = rect.bottom;

        line.setAttribute("x1", x);
        line.setAttribute("y1", y);
        line.setAttribute("x2", bubbleX);
        line.setAttribute("y2", bubbleY);

        line.style.opacity = "0.6";
      }

      function hideHoverLine() {

        const line = document.getElementById("hoverLine");
        if (line) {
          line.style.opacity = "0";
        }

      }

function openCityPanel(city) {

        const panel = document.getElementById("infoPanel");

        const showCountry =
          city.country &&
          city.name.toLowerCase() !== city.country.toLowerCase();

        panel.innerHTML = `
          <div class="panelHeader" style="
            position:sticky;
            top:0;
            z-index:5;
            background:rgba(0,0,0,0.95);
            backdrop-filter:blur(16px);
            padding-bottom:10px;
          ">
            <button class="closePanel" style="position:absolute;top:6px;right:0;">✕</button>
            <div style="
              display:flex;
              justify-content:space-between;
              align-items:center;
              margin-top:4px;
              padding-right:40px;
            ">
              <div>
                <h2 style="margin:0;">${city.name}</h2>
                ${showCountry ? `<h4 style="margin:2px 0 0 0;opacity:0.7;">${city.country}</h4>` : ""}
              </div>
              <div id="localTime" style="font-size:14px;opacity:0.85;white-space:nowrap;"></div>
            </div>
          </div>

          <div id="articlesViewport" style="position:relative;overflow-y:auto;flex:1;">
            <div id="articlesTrack" style="display:flex;flex-direction:column;height:auto;">
            </div>
          </div>
        `;

        panel.classList.add("active");

        setTimeout(() => {
          targetZoom = Math.max(2.4, camera.position.z - 0.6);
        }, 250);

        // =====================================
        // Infinite Scroll Pagination
        // =====================================

        let offset = 0;
        const limit = 5;
        let loading = false;
        let hasMore = true;

        const track = panel.querySelector("#articlesTrack");
        const viewport = panel.querySelector("#articlesViewport");

        function loadMore() {

          if (loading || !hasMore) return;
          loading = true;

          fetch(
            `https://earth-wjr6.onrender.com/api/news/city/${city.id}?limit=${limit}&offset=${offset}`
          )
            .then(res => res.json())
            .then(articles => {

              if (!articles.length && offset === 0) {
                track.innerHTML = "<div style='padding:10px;'>No recent articles.</div>";
                hasMore = false;
                loading = false;
                return;
              }

              if (articles.length < limit) {
                hasMore = false;
              }

              articles.forEach(article => {

                const div = document.createElement("div");

                div.innerHTML = `
                  <div style="
                    margin-bottom:14px;
                    border-bottom:1px solid rgba(255,255,255,0.1);
                    padding-bottom:8px;
                  ">
                    <a href="${article.url}" target="_blank" style="color:#4da6ff;">
                      <strong>${article.title}</strong>
                    </a>
                    <div style="font-size:11px;opacity:0.6;margin-top:4px;">
                      ${article.source_name} • 
                      ${new Date(article.published_at).toLocaleDateString()}
                    </div>
                    <p style="margin-top:6px;">
                      ${article.summary || ""}
                    </p>
                  </div>
                `;

                track.appendChild(div);

              });

              offset += limit;
              loading = false;

            })
            .catch(err => {
              console.error("City article load error:", err);
              loading = false;
            });

        }

        // Initial load
        loadMore();

        // Scroll detection
        viewport.addEventListener("scroll", () => {

          const threshold = 120;

          if (
            viewport.scrollTop + viewport.clientHeight >=
            viewport.scrollHeight - threshold
          ) {
            loadMore();
          }

        });

        // =====================================
        // Local Time
        // =====================================

        const timeElement = document.getElementById("localTime");

        function updateLocalTime() {
          const nowUTC = new Date();
          const offsetHours = city.lon / 15;
          const localTime = new Date(nowUTC.getTime() + offsetHours * 3600000);
          timeElement.textContent = localTime.toLocaleTimeString([], {
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
          });
        }

        updateLocalTime();
        if (timeInterval) clearInterval(timeInterval);
        timeInterval = setInterval(updateLocalTime, 1000);

        // =====================================
        // Close Button
        // =====================================

        const closeBtn = panel.querySelector(".closePanel");

        closeBtn.addEventListener("click", () => {
          panel.classList.remove("active");
          clearInterval(timeInterval);
          timeInterval = null;
          isFocused = false;
          selectedNodeIndex = null;
          scheduleAmbientResume();
        });

      }      

        
      function openCountryPanel(country) {

        const panel = document.getElementById("infoPanel");

        panel.innerHTML = `
          <div class="panelHeader" style="
            position:sticky;
            top:0;
            z-index:5;
            background:rgba(0,0,0,0.95);
            backdrop-filter:blur(16px);
            padding-bottom:10px;
          ">
            <button class="closePanel" style="position:absolute;top:6px;right:0;">✕</button>
            <div style="
              display:flex;
              justify-content:space-between;
              align-items:center;
              margin-top:4px;
              padding-right:40px;
            ">
              <div>
                <h2 style="margin:0;">${country.name}</h2>
              </div>
            </div>
          </div>

          <div id="articlesViewport" style="position:relative;overflow-y:auto;flex:1;">
            <div id="articlesTrack" style="display:flex;flex-direction:column;height:auto;">
            </div>
          </div>
        `;

        panel.classList.add("active");

        setTimeout(() => {
          targetZoom = Math.max(2.4, camera.position.z - 0.6);
        }, 250);


        // =====================================
        // Infinite Scroll Pagination
        // =====================================

        let offset = 0;
        const limit = 5;
        let loading = false;
        let hasMore = true;

        const track = panel.querySelector("#articlesTrack");
        const viewport = panel.querySelector("#articlesViewport");

        function loadMore() {

          if (loading || !hasMore) return;

          loading = true;

          fetch(
            `https://earth-wjr6.onrender.com/api/news/country/${country.id}?limit=${limit}&offset=${offset}`
          )
            .then(res => res.json())
            .then(articles => {

              if (!articles.length && offset === 0) {
                track.innerHTML = "<div style='padding:10px;'>No recent articles.</div>";
                hasMore = false;
                loading = false;
                return;
              }

              if (articles.length < limit) {
                hasMore = false;
              }

              articles.forEach(article => {

                const div = document.createElement("div");

                div.innerHTML = `
                  <div style="
                    margin-bottom:14px;
                    border-bottom:1px solid rgba(255,255,255,0.1);
                    padding-bottom:8px;
                  ">
                    <a href="${article.url}" target="_blank" style="color:#4da6ff;">
                      <strong>${article.title}</strong>
                    </a>
                    <div style="font-size:11px;opacity:0.6;margin-top:4px;">
                      ${article.source_name} • 
                      ${new Date(article.published_at).toLocaleDateString()}
                    </div>
                    <p style="margin-top:6px;">
                      ${article.summary || ""}
                    </p>
                  </div>
                `;

                track.appendChild(div);

              });

              offset += limit;
              loading = false;

            })
            .catch(err => {

              console.error("Country article load error:", err);
              loading = false;

            });

        }

        // Initial load
        loadMore();

        // Scroll detection
        viewport.addEventListener("scroll", () => {

          const threshold = 120;

          if (
            viewport.scrollTop + viewport.clientHeight >=
            viewport.scrollHeight - threshold
          ) {
            loadMore();
          }

        });


        // =====================================
        // CLOSE BUTTON
        // =====================================

        const closeBtn = panel.querySelector(".closePanel");

        closeBtn.addEventListener("click", () => {

          panel.classList.remove("active");

          if (timeInterval) {
            clearInterval(timeInterval);
            timeInterval = null;
          }

          isFocused = false;
          selectedNodeIndex = null;
          scheduleAmbientResume();

        });

      }


      window.addEventListener("touchstart", (e) => {

        if (e.touches.length === 1) {

          touchDragging = true;

          touchPrevX = e.touches[0].clientX;
          touchPrevY = e.touches[0].clientY;

          selectedNodeIndex = null;
          isFocused = false;

        }

      }, { passive: false });



      window.addEventListener("touchmove", (e) => {

        if (!touchDragging || e.touches.length !== 1) return;

        e.preventDefault();

        const deltaX =
          (e.touches[0].clientX - touchPrevX) * 0.005;

        const deltaY =
          (e.touches[0].clientY - touchPrevY) * 0.005;

        applyYaw(deltaX);
        applyTilt(-deltaY);

        touchPrevX = e.touches[0].clientX;
        touchPrevY = e.touches[0].clientY;

      }, { passive: false });



      window.addEventListener("touchend", () => {

        touchDragging = false;

      });


      /* ===============================
         Zoom controls: wheel, trackpad pinch, iOS pinch
      =============================== */

      window.addEventListener("wheel", e => {

        pauseAmbientRotation();

        const panel =
          document.getElementById("infoPanel");

        // If panel is open and mouse is over it → allow scroll
        if (
          panel.classList.contains("active") &&
          panel.contains(e.target)
        ) {
          return; // allow normal scroll
        }

        e.preventDefault();

        const isPinchZoom = e.ctrlKey;

        if (isPinchZoom) {

          zoomVelocity += e.deltaY * 0.0006;
          return;

        }

        const rotateSpeed = 0.003;

        yawVelocity  += e.deltaX * rotateSpeed;
        tiltVelocity += e.deltaY * rotateSpeed * 0.6;

      }, { passive: false });




      let initialPinchDistance = null;

      function getDistance(touches) {
        return Math.sqrt(
          (touches[0].clientX - touches[1].clientX) ** 2 +
          (touches[0].clientY - touches[1].clientY) ** 2
        );
      }


      window.addEventListener("touchstart", e => {
        if (e.touches.length === 2) {
          initialPinchDistance = getDistance(e.touches);
        }
      }, { passive: false });

      window.addEventListener("touchmove", e => {
        if (e.touches.length === 2 && initialPinchDistance !== null) {

          e.preventDefault();

          const currentDistance = getDistance(e.touches);
          const delta = initialPinchDistance - currentDistance;

          // Add inertia instead of direct zoom
          zoomVelocity += delta * 0.0008;

          initialPinchDistance = currentDistance;
        }
      }, { passive: false });

      window.addEventListener("touchend", e => {
        if (e.touches.length < 2) {
          initialPinchDistance = null;
        }
      });

      /* ===============================
   Generate Compass Ticks (16 divisions)
=============================== */

const tickGroup = document.querySelector(".compass-ticks");

if (tickGroup) {

  for (let i = 0; i < 16; i++) {

    const angle = (i / 16) * Math.PI * 2;

    const innerRadius = i % 4 === 0 ? 30 : 36; // major every 4
    const outerRadius = 44;

    const x1 = 50 + innerRadius * Math.cos(angle);
    const y1 = 50 + innerRadius * Math.sin(angle);

    const x2 = 50 + outerRadius * Math.cos(angle);
    const y2 = 50 + outerRadius * Math.sin(angle);

    const line = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "line"
    );

    line.setAttribute("x1", x1);
    line.setAttribute("y1", y1);
    line.setAttribute("x2", x2);
    line.setAttribute("y2", y2);

    line.setAttribute(
      "class",
      i % 4 === 0 ? "compass-tick major" : "compass-tick"
    );

    tickGroup.appendChild(line);
  }

}



      /* ===============================
         SEARCH MODULE
      =============================== */

      const searchInput = document.getElementById("citySearch");
      const resultsContainer = document.getElementById("searchResults");

      searchInput.addEventListener("input", () => {

        const query = searchInput.value.trim().toLowerCase();

        if (query.length < 2) {
          resultsContainer.style.display = "none";
          return;
        }

        const matches = cities
          .filter(city => city.name.toLowerCase().startsWith(query))
          .slice(0, 5);

        resultsContainer.innerHTML = "";

        matches.forEach(city => {

          const div = document.createElement("div");
          div.className = "searchItem";
          div.textContent = (city.country && city.name !== city.country)
            ? `${city.name}, ${city.country}`
            : city.name;


          div.addEventListener("click", () => {
            

            focusCity(city);
            resultsContainer.style.display = "none";
            searchInput.value = city.name;

          });

          resultsContainer.appendChild(div);
        });

        resultsContainer.style.display = matches.length ? "block" : "none";
      });

      window.addEventListener("click", (e) => {
        if (!document.getElementById("searchContainer").contains(e.target)) {
          resultsContainer.style.display = "none";
        }
      });


      /* ===============================
         FOCUS CITY ROTATION
      =============================== */


      // FIX #2: Compute the globeQuat that brings (lat,lon) to face the camera.
      function computeFocusQuat(lat, lon) {

        const phi   = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);

        const x = -Math.sin(phi) * Math.cos(theta);
        const z =  Math.sin(phi) * Math.sin(theta);
        const y =  Math.cos(phi);

        const cityVector = new THREE.Vector3(x, y, z).normalize();

        // Camera looks down negative Z by default.
        // So we rotate the globe so the city faces +Z.
        const targetDirection = new THREE.Vector3(0, 0, 1);

        const quat = new THREE.Quaternion()
          .setFromUnitVectors(cityVector, targetDirection);

        return quat;

      }


      function startFocus(lat, lon) {
        focusTargetQuat = computeFocusQuat(lat, lon);
        isFocused       = true;
        yawVelocity     = 0;
        tiltVelocity    = 0;
      }


      function focusCity(city) {

        const index = cities.findIndex(c => c.name === city.name);
        selectedNodeIndex = index;

        // FIX #2: delegate rotation to startFocus
        startFocus(city.lat, city.lon);

        // Softer contextual zoom
        targetZoom = Math.max(2.4, camera.position.z - 0.6);

        // ===============================
        // Ring Burst Placement
        // ===============================

        const phi = (90 - city.lat) * (Math.PI / 180);
        const theta = (city.lon + 180) * (Math.PI / 180);
        const ringAltitude = 0.03;

        const ringX = -(radius + ringAltitude) * Math.sin(phi) * Math.cos(theta);
        const ringZ =  (radius + ringAltitude) * Math.sin(phi) * Math.sin(theta);
        const ringY =  (radius + ringAltitude) * Math.cos(phi);

        ringGroup.position.set(ringX, ringY, ringZ);
        ringGroup.lookAt(0, 0, 0);

        ringStates.forEach((state, i) => {
          state.progress = 0;
          state.delay = i * ringBurstDelay;
          state.active = true;

          ringMeshes[i].scale.set(1, 1, 1);
          ringMeshes[i].material.opacity = 0;
        });

      }

      function focusCountry(country) {

        const index = countries.findIndex(
          c => c.name === country.name
        );

        selectedNodeIndex = index;

        // FIX #2: delegate rotation to startFocus
        startFocus(country.lat, country.lon);

        // Softer contextual zoom
        targetZoom = Math.max(2.4, camera.position.z - 0.6);

        // ===============================
        // Ring Burst Placement
        // ===============================

        const phi = (90 - country.lat) * (Math.PI / 180);
        const theta = (country.lon + 180) * (Math.PI / 180);
        const ringAltitude = 0.03;

        const ringX = -(radius + ringAltitude) * Math.sin(phi) * Math.cos(theta);
        const ringZ =  (radius + ringAltitude) * Math.sin(phi) * Math.sin(theta);
        const ringY =  (radius + ringAltitude) * Math.cos(phi);

        ringGroup.position.set(ringX, ringY, ringZ);
        ringGroup.lookAt(0, 0, 0);

        ringStates.forEach((state, i) => {

          state.progress = 0;
          state.delay = i * ringBurstDelay;
          state.active = true;

          ringMeshes[i].scale.set(1, 1, 1);
          ringMeshes[i].material.opacity = 0;

        });

      }

      let targetCityOpacity = 0.15;
      let targetCountryOpacity = 1.0;

      // ===============================
      // Drag Scroll for Info Panel
      // ===============================

      const infoPanel =
        document.getElementById("infoPanel");

      let panelScrolling = false;
      let panelStartY;
      let panelScrollStart;

      infoPanel.addEventListener("mousedown", (e) => {

        panelScrolling = true;
        panelStartY = e.clientY;
        panelScrollStart = infoPanel.scrollTop;

        infoPanel.style.cursor = "grabbing";

      });

      window.addEventListener("mousemove", (e) => {

        if (!panelScrolling) return;

        const delta =
          e.clientY - panelStartY;

        infoPanel.scrollTop =
          panelScrollStart - delta;

      });

      window.addEventListener("mouseup", () => {

        panelScrolling = false;
        infoPanel.style.cursor = "grab";

      });

      infoPanel.style.cursor = "grab";




      // Animation loop
      function animate(){
        requestAnimationFrame(animate);




// --------------------------------
        // Trackpad Rotation Inertia — FIX #3
        // --------------------------------
        if (Math.abs(yawVelocity) > 0.00001 ||
            Math.abs(tiltVelocity) > 0.00001) {
          applyYaw(-yawVelocity);
          applyTilt(tiltVelocity);
          yawVelocity  *= 0.90;
          tiltVelocity *= 0.90;
        }

        // --------------------------------
        // Ambient Equatorial Rotation — FIX #3
        // --------------------------------
        if (!dragging && !isFocused && !ambientPaused && ambientEnabled) {
          applyYaw(ambientSpeed);
        }


        // --------------------------------
        // Zoom Physics
        // --------------------------------
        zoomVelocity *= zoomFriction;
        targetZoom += zoomVelocity;
        targetZoom = Math.max(1.5, Math.min(5, targetZoom));

        const zoomDelta = targetZoom - camera.position.z;

        const easingStrength = 0.05;
        const dynamicEasing =
          easingStrength *
          Math.min(Math.abs(zoomDelta) * 2, 1);

        camera.position.z += zoomDelta * dynamicEasing;



// --------------------------------
        // Globe Rotation — FIX #2: slerp toward focus target
        // --------------------------------

        if (isFocused && focusTargetQuat) {

          globeQuat.slerp(focusTargetQuat, 0.07);

          if (globeQuat.angleTo(focusTargetQuat) < 0.0005) {
            globeQuat.copy(focusTargetQuat);
            focusTargetQuat = null;
          }

        }

        scene.quaternion.copy(globeQuat);



        // --------------------------------
        // Visual Updates
        // --------------------------------
        updateNodeGlow();
        updateHoverLabels();

        // Leader Line Projection
        const panelOpen =
          document.getElementById("infoPanel")
            .classList.contains("active");

        const hoveringDifferentCity =
          hoveredIndex !== null &&
          hoveredIndex !== selectedNodeIndex;

        if (hoveredCityPosition &&
            (!panelOpen || hoveringDifferentCity)) {

          const vector =
            hoveredCityPosition.clone();

          vector.project(camera);

          const x =
            (vector.x * 0.5 + 0.5) *
            window.innerWidth;

          const y =
            (-vector.y * 0.5 + 0.5) *
            window.innerHeight;

          updateHoverLine(x, y);

        } else {

          hideHoverLine();
        }

        // --------------------------------
        // Ring Burst Animation
        // --------------------------------
        if (isFocused &&
            selectedNodeIndex !== null) {

          ringStates.forEach((state, i) => {

            if (!state.active) return;

            if (state.delay > 0) {
              state.delay -= ringSpeed;
              return;
            }

            state.progress += ringSpeed;

            const maxScale = ringMultiplierMax;
            const scale =
              1 + state.progress * (maxScale - 1);

            ringMeshes[i].scale.set(
              scale, scale, scale
            );

            const opacity =
              Math.pow(1 - state.progress, 1.8);

            ringMeshes[i].material.opacity =
              opacity;

            if (state.progress >= 1) {
              ringMeshes[i].material.opacity = 0;
              state.active = false;
            }

          });

        } else {

          ringMeshes.forEach(ring => {
            ring.material.opacity = 0;
          });
        }

        // --------------------------------
        // Glow Pulse Update
        // --------------------------------
        if (glowPulseActive) {

          glowPulseTime += 0.03;

          if (glowPulseTime >= 1) {
            glowPulseActive = false;
          }
        }

        // --------------------------------
        // Earth Twinkle Update
        // --------------------------------
        const earthColorAttr =
          earthPoints.geometry.attributes.color;

        for (let i = 0;
             i < earthTwinkleTimers.length;
             i++) {

          if (earthTwinkleTimers[i] <= 0 &&
              Math.random() < earthTwinkleChance) {
            earthTwinkleTimers[i] =
              earthTwinkleDuration;
          }

          let brightness =
            earthBaseBrightness[i];

          if (earthTwinkleTimers[i] > 0) {

            const t =
              earthTwinkleTimers[i] /
              earthTwinkleDuration;

            const fade =
              Math.sin(t * Math.PI);

            brightness *=
              (1 -
               earthTwinkleIntensity *
               fade);

            earthTwinkleTimers[i] -= 0.016;
          }

          earthColorAttr.setXYZ(
            i,
            brightness,
            brightness,
            brightness
          );
        }

        earthColorAttr.needsUpdate = true;


// --------------------------------
        // Compass Rotation
        // --------------------------------
        updateCompass();

        // --------------------------------
        // Opacity Blending
        // --------------------------------
        cityMat.opacity +=
          (targetCityOpacity -
           cityMat.opacity) * 0.08;

        countryMat.opacity +=
          (targetCountryOpacity -
           countryMat.opacity) * 0.08;

        renderer.render(scene, camera);
      }


      animate();
    }

    class GeoBoundaryLayer {

      constructor(scene, radius) {
        this.scene = scene;
        this.radius = radius;
        this.group = new THREE.Group();
        this.scene.add(this.group);
      }

      latLonToVector3(lat, lon, altitude = 0.01) {

        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);

        const r = this.radius + altitude;

        const x = -r * Math.sin(phi) * Math.cos(theta);
        const z =  r * Math.sin(phi) * Math.sin(theta);
        const y =  r * Math.cos(phi);

        return new THREE.Vector3(x, y, z);
      }

      loadGeoJSON(geojson) {

        geojson.features.forEach(feature => {

          const geometry = feature.geometry;

          if (geometry.type === "Polygon") {
            this.drawPolygon(geometry.coordinates);
          }

          if (geometry.type === "MultiPolygon") {
            geometry.coordinates.forEach(polygon => {
              this.drawPolygon(polygon);
            });
          }

        });
      }

    drawPolygon(polygon) {

      polygon.forEach(ring => {

        const points = [];

        ring.forEach(coord => {
          const [lon, lat] = coord;
          points.push(this.latLonToVector3(lat, lon));
        });

        const geometry = new THREE.BufferGeometry().setFromPoints(points);

        const material = new THREE.ShaderMaterial({
          transparent: true,
          uniforms: {
            color: { value: new THREE.Color(1.5, 1.5, 1.5) },
            opacity: { value: 0.99 }
          },
          vertexShader: `
            varying float vDot;

            void main() {

              vec4 worldPosition = modelMatrix * vec4(position, 1.0);
              vec3 normal = normalize(worldPosition.xyz);

              vec3 cameraDir = normalize(cameraPosition - worldPosition.xyz);

              vDot = dot(normal, cameraDir);

              gl_Position = projectionMatrix * viewMatrix * worldPosition;
            }
          `,
          fragmentShader: `
            uniform vec3 color;
            uniform float opacity;
            varying float vDot;

            void main() {

              // 1. Clamp facing value
              //    vDot = 1.0 (fully facing camera)
              //    vDot = 0.0 (horizon)
              //    vDot < 0.0 (backside)
              float facing = clamp(vDot, 0.0, 1.0);

              // 2. Dark backside
              float backsideDark = 0.06;

              // 3. Electric front hemisphere brightness
              //    Strong boost across entire visible side
              float electricBoost = 1.2 + (facing * 1.8);

              // 4. Extra center intensification
              float coreIntensity = pow(facing, 2.0) * 1.2;

              // 5. Soft horizon transition
              float horizonFade = smoothstep(0.0, 0.12, facing);

              // 6. Combine brightness
              float finalShade = mix(
                backsideDark,
                electricBoost + coreIntensity,
                horizonFade
              );

              // 7. Subtle electric shimmer
              float shimmer = sin(facing * 40.0) * 0.05;
              finalShade += shimmer * horizonFade;

              gl_FragColor = vec4(
                color * finalShade,
                opacity * horizonFade
              );
            }
          `

        });


        const line = new THREE.Line(geometry, material);
        this.group.add(line);

      });
    }


    setVisible(value) {
      this.group.visible = value;
    }

    setColor(color) {
      this.group.children.forEach(child => {
        child.material.uniforms.color.value.set(color);
      });
    }

  }



  </script>
</body>
</html>