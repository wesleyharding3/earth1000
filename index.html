<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Population Globe with Zoom</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: #000;

      font-family: -apple-system, BlinkMacSystemFont,
                   "Segoe UI", Roboto,
                   "Helvetica Neue", Arial,
                   sans-serif;

      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    canvas { display: block; }
    #searchContainer {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 340px;
      z-index: 10;
    }

    #citySearch {
      width: 100%;
      padding: 12px 20px;
      border-radius: 40px;
      border: 1.5px solid rgba(255, 255, 255, 0.9);
      outline: none;
      background: #000;
      color: #fff;
      font-size: 15px;
      letter-spacing: 0.5px;
      box-shadow: 0 0 18px rgba(255,255,255,0.06);
      transition: border 0.2s ease, box-shadow 0.2s ease;
    }

    #citySearch:focus {
      border: 1.5px solid #ffffff;
      box-shadow: 0 0 12px rgba(255,255,255,0.4);
    }

    #searchResults {
      margin-top: 8px;
      background: rgba(0,0,0,0.96);
      border-radius: 14px;
      max-height: 210px; /* ~5 results */
      overflow-y: auto;
      display: none;
      box-shadow: 0 0 15px rgba(255,255,255,0.04);
    }

   .searchItem {
      padding: 10px 14px;
      cursor: pointer;
      color: #fff;
      font-size: 14px;
    }

    .searchItem:hover {
      background: rgba(255,255,255,0.08);
    }

    #cityList {
      display: none;
      position: absolute; top: 5px; right: -500px; width: 250px; max-height: 85vh; overflow-y: auto;
      background: rgba(0,0,0,0.75); color: #fff; padding: 8px; font-size: 10px; border-radius: 8px;
    }
    #cityList ul { list-style: none; padding: 0; margin: 0; }
    #cityList li { margin-bottom: 5px; border-bottom: 1px solid rgba(255,255,255,0.08); padding-bottom: 3px; }
    #cityList li:last-child { border-bottom: none; }
    #infoPanel {
      position: fixed; bottom: -300px; left: 0; width: 100%; height: 260px;
      background: rgba(0,0,0,0.95); color: white; padding: 20px; box-sizing: border-box;
      transition: bottom 0.4s ease; overflow-y: auto; border-top: 2px solid rgba(255,255,255,0.1);
    }
    #infoPanel.active { bottom: 0; }
    #infoPanel a { color: #4da6ff; text-decoration: none; display: block; margin-bottom: 8px; }
    #infoPanel a:hover { text-decoration: underline; }

    #infoPanel button.closePanel {
      position: absolute;
      top: 10px;
      right: 15px;
      background: #444;
      color: #fff;
      border: none;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 12px;
      border-radius: 4px;
    }
    #infoPanel button.closePanel:hover {
       background: #666;
    }

    .cityBubble {
      position: absolute;
      pointer-events: none;
      transform: translate(-50%, -140%);
      transition: opacity 0.2s ease, transform 0.2s ease;
      font-size: 11px;
      color: #fff;
      white-space: nowrap;
    }

    .bubbleContent {
      background: rgba(0, 0, 0, 0.88);
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 6px 10px;
      border-radius: 10px;
      backdrop-filter: blur(6px);
      box-shadow: 0 0 12px rgba(0, 0, 0, 0.5);
    }

    .bubbleTitle {
      font-weight: 600;
      font-size: 12px;
      margin-bottom: 2px;
    }

    .bubbleMeta {
      font-size: 10px;
      opacity: 0.7;
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .bubbleWrapper {
      position: relative;
      display: inline-block;
    }

    .bubbleOutline {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .bubbleRect {
      fill: rgba(0, 0, 0, 0.88);
      stroke: rgba(255, 255, 255, 0.4);
      stroke-width: 1.2;
    }

    .bubbleContent {
      position: relative;
      padding: 6px 12px;
      border-radius: 12px;
      color: #fff;
      white-space: nowrap;
    }

    .cityBubble.hovered .bubbleContent {
      animation: bubblePulse 11s ease-in-out infinite;
    }

    @keyframes electricPulse {
      0% {
        box-shadow:
          0 0 6px rgba(255,255,255,0.08),
          0 0 0px rgba(0,150,255,0);
      }
      35% {
        box-shadow:
          0 0 18px rgba(255,255,255,0.35),
          0 0 28px rgba(0,150,255,0.6);
      }
      70% {
        box-shadow:
          0 0 10px rgba(255,255,255,0.2),
          0 0 14px rgba(0,150,255,0.3);
      }
      100% {
        box-shadow:
          0 0 6px rgba(255,255,255,0.08),
          0 0 0px rgba(0,150,255,0);
      }
    }


/* ===============================
   Compass
=============================== */

#compass {

  position: absolute;
  top: 20px;
  right: 20px;

  width: 56px;
  height: 56px;

  border-radius: 50%;

  backdrop-filter: blur(12px);
  background: rgba(0, 0, 0, 0.65);
  border: 1px solid rgba(255,255,255,0.25);

  display: flex;
  align-items: center;
  justify-content: center;

  cursor: pointer;
  user-select: none;

  z-index: 30;

  transition: transform 0.2s ease;
}

#compass:hover {
  transform: scale(1.08);
}

.compass-svg {
  width: 100%;
  height: 100%;
}

.compass-circle {
  fill: none;
  stroke: rgba(255,255,255,0.5);
  stroke-width: 2;
}

.compass-letter {
  fill: white;
  font-size: 12px;
  font-weight: 600;
  opacity: 0.9;
}

.compass-arrow-line {
  stroke: white;
  stroke-width: 2;
}

.compass-arrow-head {
  fill: red;
}

.compass-tick {
  stroke: rgba(255,255,255,0.6);
  stroke-width: 1;
}

.compass-tick.major {
  stroke-width: 2;
}




  </style>
</head>

<body>
  <div id="cityList"><h3>Geopolitical Cities</h3><ul id="list"></ul></div>
  <div id="infoPanel"><div id="panelContent"></div></div>
  <div id="cityLabels" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;"></div>
  <svg id="uiOverlay"
       style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:5;">
    <line id="hoverLine"
        stroke="white"
        stroke-width="1"
        opacity="0"/>
  </svg>
  <div id="searchContainer">
    <input type="text" id="citySearch" placeholder="Search city..." />
    <div id="searchResults"></div>
  </div>

<!-- Compass Widget -->
<div id="compass">
  <svg class="compass-svg" viewBox="0 0 100 100">
    
    <!-- Outer Ring -->
    <circle cx="50" cy="50" r="46" class="compass-circle" />

    <!-- Tick Marks -->
    <g class="compass-ticks"></g>

    <!-- Cardinal Letters -->
    <text x="50" y="18" text-anchor="middle" class="compass-letter">N</text>
    <text x="50" y="92" text-anchor="middle" class="compass-letter">S</text>
    <text x="8" y="54" text-anchor="middle" class="compass-letter">W</text>
    <text x="92" y="54" text-anchor="middle" class="compass-letter">E</text>

    <!-- Arrow -->
    <line x1="50" y1="50" x2="50" y2="25" class="compass-arrow-line"/>
    <polygon points="50,15 45,25 55,25" class="compass-arrow-head"/>

  </svg>
</div>




  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js";

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 3;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    let yaw = 0;
    let pitch = 0;
    const maxTilt = Math.PI / 2.2;

          // ===============================
      // Window Resize Handling
      // ===============================

      window.addEventListener("resize", () => {

        const width = window.innerWidth;
        const height = window.innerHeight;

        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

      });


    const radius = 1;

    // Smooth zoom target
    let targetZoom = camera.position.z;
    let zoomVelocity = 0;
    const zoomFriction = 0.92;


    /* ===============================
       Load Earth texture and initialize
    =============================== */
    const loader = new THREE.TextureLoader();
    const earthTexture = loader.load(
      "https://threejs.org/examples/textures/land_ocean_ice_cloud_2048.jpg",
      () => {

        fetch("https://earth-wjr6.onrender.com/api/cities")
          .then(res => res.json())
          .then(data => {
            init(data);
          })
          .catch(err => {
            console.error("Failed to load cities:", err);
          });

      }
    );


    function init(cities) {
      // Earth points
      const earthPointCount = 10000;
      const earthPositions = [];
      const earthColors = [];
      const earthBaseBrightness = [];

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = earthTexture.image.width;
      canvas.height = earthTexture.image.height;
      ctx.drawImage(earthTexture.image, 0, 0);
      const imageData = ctx.getImageData(0,0,canvas.width,canvas.height).data;

      for(let i=0;i<earthPointCount;i++){
        const u=Math.random(), v=Math.random();
        const theta = 2*Math.PI*u;
        const phi = Math.acos(2*v-1);
        const x = radius*Math.sin(phi)*Math.cos(theta);
        const y = radius*Math.cos(phi);
        const z = radius*Math.sin(phi)*Math.sin(theta);
        earthPositions.push(x,y,z);
        const lon=Math.atan2(z,x), lat=Math.asin(y/radius);
        const uTex=(lon/(2*Math.PI))+0.5;
        const vTex=0.5-(lat/Math.PI);
        const px = Math.floor(uTex*canvas.width), py = Math.floor(vTex*canvas.height);
        const idx=(py*canvas.width+px)*4;
        const r=imageData[idx], g=imageData[idx+1], b=imageData[idx+2];
        const bright = (r+g+b)/3;
        const c = bright>120 ? 0.2 : 1.0;
        earthColors.push(c,c,c);
        earthBaseBrightness.push(c);
      }

      const earthGeo = new THREE.BufferGeometry();
      earthGeo.setAttribute("position", new THREE.Float32BufferAttribute(earthPositions,3));
      earthGeo.setAttribute("color", new THREE.Float32BufferAttribute(earthColors,3));
      const earthMat = new THREE.PointsMaterial({ size:0.006, vertexColors:true, transparent:true, depthWrite:false });
      const earthPoints = new THREE.Points(earthGeo, earthMat);
      scene.add(earthPoints);

            // ------------------------------
      // Earth Twinkle System
      // ------------------------------

      const earthTwinkleChance = 0.04;
      const earthTwinkleDuration = 0.2;
      const earthTwinkleIntensity = 0.6;

      const earthTwinkleTimers = new Array(earthPointCount).fill(0);


      /* ===============================
         FULL CITY LIST GOES HERE
      =============================== */


      // City points
      const citySize = 0.0375;
      const ringBurstDelay = 0.18;
      const ringSpeed = 0.008; 
      const positions = [];
      const ringMultiplierMax = 8;
      const ringStartRadius = 0.005;
      const ringThickness = 0.0001;
      const ringOuterMultiplier = 8;
      const listElement = document.getElementById("list");
      cities.forEach(city=>{
        const {name,lat,lon,country}=city;
        const phi=(90-lat)*(Math.PI/180);
        const theta=(lon+180)*(Math.PI/180);
        const x=-radius*Math.sin(phi)*Math.cos(theta);
        const z= radius*Math.sin(phi)*Math.sin(theta);
        const y= radius*Math.cos(phi);
        positions.push(x,y,z);
        const li=document.createElement("li");
        li.textContent = (country && name !== country)
          ? `${name}, ${country}`
          : name;
        listElement.appendChild(li);
      });

      const cityGeo=new THREE.BufferGeometry();
      cityGeo.setAttribute("position", new THREE.Float32BufferAttribute(positions,3));

      function createGlowTexture(){
        const size=128;
        const glowCanvas=document.createElement("canvas");
        glowCanvas.width=size; glowCanvas.height=size;
        const ctx=glowCanvas.getContext("2d");
        const outerRadius = size * 0.15;
        const grad=ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
        grad.addColorStop(0,"rgba(255,200,120,1)");
        grad.addColorStop(0.4,"rgba(255,140,40,0.7)");
        grad.addColorStop(0.8,"rgba(255,80,20,0.3)");
        grad.addColorStop(1,"rgba(255,80,20,0)");
        ctx.fillStyle=grad; ctx.fillRect(0,0,size,size);
        return new THREE.CanvasTexture(glowCanvas);
      }

      const glowTexture=createGlowTexture();
      const cityMat=new THREE.PointsMaterial({
        size:citySize,
        sizeAttenuation: true,
        map:glowTexture,
        transparent:true,
        blending:THREE.AdditiveBlending,
        depthWrite:false
      });
      const cityPoints=new THREE.Points(cityGeo,cityMat);
      scene.add(cityPoints);

            // ===============================
      // Selection Ring Burst
      // ===============================


      const ringGroup = new THREE.Group();
      scene.add(ringGroup);

      const ringCount = 3;
      const ringMeshes = [];
      const ringStates = [];

      for (let i = 0; i < ringCount; i++) {

        const ringGeo = new THREE.RingGeometry(
          ringStartRadius,
          ringStartRadius + ringThickness * ringOuterMultiplier,
          64
        );


        const ringMat = new THREE.MeshBasicMaterial({
          color: new THREE.Color(1.0, 0.6, 0.25),
          transparent: true,
          opacity: 0,
          side: THREE.DoubleSide,
          depthWrite: false,
          blending: THREE.NormalBlending
        });


        const ring = new THREE.Mesh(ringGeo, ringMat);


        ringGroup.add(ring);
        ringMeshes.push(ring);

        ringStates.push({
          progress: 0,
          delay: i * ringBurstDelay,
          active: false
        });
      }
     

      /* >>>>> INSERTED: GEO BOUNDARY LOADER START */

      const boundaryLayer = new GeoBoundaryLayer(scene, radius);

      fetch("custom.geo.json")
        .then(res => res.json())
        .then(data => {
          boundaryLayer.loadGeoJSON(data);
        });

      // ------------------------------
      // Utility: check if city is facing the camera
      // ------------------------------

      function isCityVisible(pointPos, camera) {
 
        const pointVector = pointPos.clone().normalize();


        const cameraDir = new THREE.Vector3();
        camera.getWorldDirection(cameraDir).normalize();

        const dot = cameraDir.dot(pointVector);
        return dot < 0;
      }


      function updateCityGlow() {

        const cameraDir = new THREE.Vector3();
        camera.getWorldDirection(cameraDir).normalize();

        const positionsAttr = cityPoints.geometry.attributes.position;
        const count = positionsAttr.count;

        if (!cityPoints.geometry.attributes.color) {
          const colors = new Float32Array(count * 3);
          cityPoints.geometry.setAttribute(
            "color",
            new THREE.BufferAttribute(colors, 3)
          );
          cityMat.vertexColors = true;
        }

        const colors = cityPoints.geometry.attributes.color;

        for (let i = 0; i < count; i++) {

          const cityPos = new THREE.Vector3();
          cityPos.fromBufferAttribute(positionsAttr, i);
          cityPos.applyMatrix4(cityPoints.matrixWorld);
          cityPos.normalize();

          let dot = -cameraDir.dot(cityPos);
          let normalized = (dot + 1) / 2;
          const minGlow = 0.15;
          let glow = minGlow + (1 - minGlow) * Math.pow(normalized, 2.5);

          if (glowPulseActive && i === selectedCityIndex) {
            const pulse = 1 + 0.4 * Math.sin(glowPulseTime * Math.PI);
            glow *= pulse;
          }  


          colors.setXYZ(
            i,
            glow,
            glow * 0.6,
            glow * 0.25
          );
        }

        colors.needsUpdate = true;
      }



      const cityLabelsContainer = document.getElementById("cityLabels");
      const cityLabels = cities.map(city => {

        const div = document.createElement("div");

        div.innerHTML = `
          <div class="bubbleWrapper">

            <svg class="bubbleOutline">
              <rect class="bubbleRect"
                    x="0"
                    y="0"
                    rx="12"
                    ry="12"
                    width="100%"
                    height="100%" />
            </svg>

            <div class="bubbleContent">
              <div class="bubbleTitle">${city.name}</div>
              <div class="bubbleMeta">
                <span class="storyCount">0 stories</span>
              </div>
            </div>

          </div>
        `;


        div.className = "cityBubble";
        div.style.position = "absolute";
        div.style.pointerEvents = "none";
        div.style.opacity = 0;
        div.style.transition = "opacity 0.2s";

        cityLabelsContainer.appendChild(div);

        return div;
      });


      const hoverMouse = new THREE.Vector2();
      let hoveredIndex = null;
      let selectedCityIndex = null;
      let isFocused = false;
      let hoveredCityPosition = null;
      let timeInterval = null;
      const compassSVG = document.querySelector(".compass-svg");



      let glowPulseTime = 0;
      let glowPulseActive = false;

      const compass = document.getElementById("compass");

      compass.addEventListener("click", () => {

        const currentEuler = new THREE.Euler()
          .setFromQuaternion(scene.quaternion, "YXZ");

        const targetEuler = new THREE.Euler(
          0,                 // remove tilt
          currentEuler.y,    // preserve longitude
          0,
          "YXZ"
        );

        targetQuaternion = new THREE.Quaternion()
          .setFromEuler(targetEuler);

        isFocused = false;
        selectedCityIndex = null;

      });




      window.addEventListener("mousemove", (event) => {
          hoverMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          hoverMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      });

      function updateHoverLabels() {

        raycaster.setFromCamera(hoverMouse, camera);
        const intersects = raycaster.intersectObject(cityPoints);

        hoveredIndex = null;
        hoveredCityPosition = null;

        const infoPanel = document.getElementById("infoPanel");
        const panelOpen = infoPanel.classList.contains("active");


        if (intersects.length > 0) {

          const index = intersects[0].index;

          if (panelOpen && index === selectedCityIndex) {
            return;
          }

          const cityPos = new THREE.Vector3();
          cityPos.fromBufferAttribute(
            cityPoints.geometry.attributes.position,
            index
          );
          cityPos.applyMatrix4(cityPoints.matrixWorld);

          if (isCityVisible(cityPos, camera)) {
            hoveredIndex = index;
            hoveredCityPosition = cityPos.clone();
          }
        }

          
        

        cities.forEach((city, i) => {

          const label = cityLabels[i];

          const pos = new THREE.Vector3(
            positions[i * 3],
            positions[i * 3 + 1],
            positions[i * 3 + 2]
          );

          pos.applyMatrix4(cityPoints.matrixWorld);

          const projected = pos.clone().project(camera);
          const x = (projected.x + 1) / 2 * window.innerWidth;
          const y = (-projected.y + 1) / 2 * window.innerHeight;

          label.style.left = `${x}px`;
          label.style.top  = `${y}px`;

          const isHovered  = (i === hoveredIndex);
          const isSelected = (i === selectedCityIndex);
          const shouldShow =
            (isHovered) ||
            (!panelOpen && isSelected);


          if (isSelected) {
            label.classList.add("focused");
          } else {
            label.classList.remove("focused");
          }

          if (isHovered) {
            label.classList.add("hovered");
          } else {
            label.classList.remove("hovered");
          }

          if (shouldShow) {

            const storyCountEl = label.querySelector(".storyCount");

            if (storyCountEl) {
              storyCountEl.textContent = `${city.storyCount || 0} stories`;
            }

            label.style.opacity = 1;
            label.style.transform = "translate(-50%, -160%) scale(1)";

            if (isHovered || isSelected) {
              triggerBubbleTyping(i);
            }            

          } else {

            label.style.opacity = 0;
            label.style.transform = "translate(-50%, -140%) scale(0.95)";
            const title = label.querySelector(".bubbleTitle");
            if (title) {
              title.dataset.typed = "false";
            }

          }

        });

      }

            // ------------------------------
      // Bubble Perimeter Trace
      // ------------------------------

      function triggerBubbleTrace(index, onComplete) {

        const bubble = cityLabels[index];
        if (!bubble) return;

        const content = bubble.querySelector(".bubbleContent");
        if (!content) return;

        content.classList.remove("trace");
        void content.offsetWidth; // restart animation
        content.classList.add("trace");

        // wait for animation to finish (~0.5s)
        setTimeout(() => {

          if (onComplete) {
            onComplete();
          }

        }, 500);

      }

      

            // ------------------------------
      // Bubble Typing Animation
      // ------------------------------

      function triggerBubbleTyping(index) {

        const bubble = cityLabels[index];
        if (!bubble) return;

        const title = bubble.querySelector(".bubbleTitle");
        if (!title) return;

        if (title.dataset.typed === "true") return;

        const fullText = cities[index].name;

        title.textContent = "";
        title.dataset.typed = "true";
        title.classList.add("typing");

        let charIndex = 0;
        const typingSpeed = 22.5; // ms per character (~0.4–0.6s total)

        function type() {

          if (charIndex < fullText.length) {

            title.textContent += fullText.charAt(charIndex);
            charIndex++;
            setTimeout(type, typingSpeed);

          } else {

            title.classList.remove("typing");

          }

        }

        type();

      }



      // ------------------------------
      // Electric Bubble Timer
      // ------------------------------

      function triggerElectricPulse() {

        cityLabels.forEach(label => {

          if (label.style.opacity === "1") {

            label.classList.remove("electric");
            void label.offsetWidth;
            label.classList.add("electric");

          }

        });

      }


      setInterval(() => {

        triggerElectricPulse();

      }, 3000);




      // Raycaster for city clicks

      const raycaster=new THREE.Raycaster();
      raycaster.params.Points.threshold=0.02;
      const mouse=new THREE.Vector2();

      window.addEventListener("click",event=>{
        mouse.x=(event.clientX/window.innerWidth)*2-1;
        mouse.y=-(event.clientY/window.innerHeight)*2+1;
        raycaster.setFromCamera(mouse,camera);
        const intersects=raycaster.intersectObject(cityPoints);
        if(intersects.length>0){
          const index=intersects[0].index;
          const cityPos = new THREE.Vector3();
          cityPos.fromBufferAttribute(cityPoints.geometry.attributes.position, index);
          cityPos.applyMatrix4(cityPoints.matrixWorld);
        
          if (isCityVisible(cityPos, camera)) {

            selectedCityIndex = index;
            isFocused = true;

            focusCity(cities[index]);
            openCityPanel(cities[index]);

          } else {
            console.log("City is on the far side, cannot select.");
          }
        }
      });

/* ===============================
   iOS TOUCH CITY SELECTION
=============================== */

      window.addEventListener("touchstart", (event) => { 
        if (event.touches.length !== 1) return;

        const touch = event.touches[0];

        mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObject(cityPoints);

        if (intersects.length > 0) {
          const index = intersects[0].index;  
          const cityPos = new THREE.Vector3();

          cityPos.fromBufferAttribute(
            cityPoints.geometry.attributes.position,
            index
          );

          cityPos.applyMatrix4(cityPoints.matrixWorld);

          if (isCityVisible(cityPos, camera)) {

            selectedCityIndex = index;
            isFocused = true;

            focusCity(cities[index]);
            openCityPanel(cities[index]);

          }
        }
      }, { passive: true });

            // ------------------------------
      // Leader Line Helpers
      // ------------------------------

      // ------------------------------
      // Leader Line Helpers
      // ------------------------------

      function updateHoverLine(x, y) {

        const line = document.getElementById("hoverLine");
        if (!line) return;

        if (hoveredIndex === null) {
          line.style.opacity = "0";
          return;
        }

        const bubble = cityLabels[hoveredIndex];
        if (!bubble) return;

        const rect = bubble.getBoundingClientRect();

        const bubbleX = rect.left + rect.width / 2;
        const bubbleY = rect.bottom;

        line.setAttribute("x1", x);
        line.setAttribute("y1", y);
        line.setAttribute("x2", bubbleX);
        line.setAttribute("y2", bubbleY);

        line.style.opacity = "0.6";
      }

      function hideHoverLine() {

        const line = document.getElementById("hoverLine");
        if (line) {
          line.style.opacity = "0";
        }

      }


        

      function openCityPanel(city){
        const panel = document.getElementById("infoPanel");

        const showCountry =
          city.country &&
          city.name.toLowerCase() !== city.country.toLowerCase();

        panel.innerHTML = `
          <button class="closePanel">✕</button>
          <div style="
            display:flex;
            justify-content:space-between;
            align-items:center;
            margin-top:4px;
          ">
            <div>
              <h2 style="margin:0;">${city.name}</h2>
              ${showCountry ? `<h4 style="margin:2px 0 0 0;opacity:0.7;">${city.country}</h4>` : ""}
            </div>

            <div id="localTime" style="
              font-size:14px;
              opacity:0.85;
              white-space:nowrap;
            "></div>
          </div>

          <div id="articlesContainer" style="margin-top:12px;font-size:13px;">
            Loading articles...
          </div>
        `;

        panel.classList.add("active");

        setTimeout(() => {
          targetZoom = 1.7;  // slightly closer than focusCity zoom
        }, 250);

        // ------------------------------
        // FETCH ARTICLES FOR CITY
        // ------------------------------

        fetch(`https://earth-wjr6.onrender.com/api/news/city/${city.id}`)
          .then(res => res.json())
          .then(articles => {

            const container = document.getElementById("articlesContainer");

            if (!articles.length) {
              container.innerHTML = "<p>No recent articles.</p>";
              return;
            }

            container.innerHTML = articles.map(article => `
              <div style="margin-bottom:14px;border-bottom:1px solid rgba(255,255,255,0.1);padding-bottom:8px;">
                <a href="${article.url}" target="_blank" style="color:#4da6ff;">
                  <strong>${article.title}</strong>
                </a>
                <div style="font-size:11px;opacity:0.6;margin-top:4px;">
                  ${article.source_name} • 
                  ${new Date(article.published_at).toLocaleDateString()}
                </div>
                <p style="margin-top:6px;">
                  ${article.summary || ""}
                </p>
              </div>
            `).join("");

          })
          .catch(err => {
            console.error("Article load error:", err);
            document.getElementById("articlesContainer").innerHTML =
              "<p>Failed to load articles.</p>";
          });

        // ------------------------------
        // LOCAL TIME
        // ------------------------------

        const timeElement = document.getElementById("localTime");

        function updateLocalTime(){

          const nowUTC = new Date();

          const offsetHours = city.lon / 15;

          const localTime = new Date(
            nowUTC.getTime() + offsetHours * 60 * 60 * 1000
          );

          const formatted = localTime.toLocaleTimeString([], {
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
          });

          timeElement.textContent = ` ${formatted}`;
        }

        updateLocalTime();

        if(timeInterval) clearInterval(timeInterval);
        timeInterval = setInterval(updateLocalTime, 1000);

        const closeBtn = panel.querySelector(".closePanel");
        closeBtn.addEventListener("click", () => {
          panel.classList.remove("active");
          clearInterval(timeInterval);
          timeInterval = null;
        });

      }


      window.addEventListener("keydown",(e)=>{
        if(e.key==="Escape"){
          document.getElementById("infoPanel").classList.remove("active");
          clearInterval(timeInterval);
          timeInterval = null;
        }
      });


      // Drag rotation
      let dragging=false, prevX=0, prevY=0;
      window.addEventListener("mousedown",e=>{
        dragging=true; 
        prevX=e.clientX; 
        prevY=e.clientY;
        selectedCityIndex = null;
        isFocused = false; 
      });
      window.addEventListener("mouseup",()=>dragging=false);
      window.addEventListener("mousemove", e=>{
        if(!dragging) return;

        const deltaX = (e.clientX - prevX) * 0.005;
        const deltaY = (e.clientY - prevY) * 0.005;

        yaw   += deltaX;
        pitch += deltaY;

        // Clamp tilt so globe never flips
        pitch = Math.max(-maxTilt, Math.min(maxTilt, pitch));

        const quaternion = new THREE.Quaternion()
          .setFromEuler(new THREE.Euler(pitch, yaw, 0, "YXZ"));

        scene.quaternion.copy(quaternion);

        prevX = e.clientX;
        prevY = e.clientY;
      });


      

// ===============================
// iOS Single-Finger Drag Rotation
// ===============================

      let touchDragging = false;
      let touchPrevX = 0;
      let touchPrevY = 0;
      
      window.addEventListener("touchstart", (e) => {  
        if (e.touches.length === 1) {
          touchDragging = true;
          touchPrevX = e.touches[0].clientX;
          touchPrevY = e.touches[0].clientY;
          selectedCityIndex = null;
          isFocused = false;
        }  
      }, {passive: false });

      window.addEventListener("touchmove", (e) => {
        if (!touchDragging || e.touches.length !== 1) return;
        e.preventDefault();

        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;

        const deltaX = (touchX - touchPrevX) * 0.005;
        const deltaY = (touchY - touchPrevY) * 0.005;

        yaw   += deltaX;
        pitch += deltaY;

        pitch = Math.max(-maxTilt, Math.min(maxTilt, pitch));

        const quaternion = new THREE.Quaternion()
          .setFromEuler(new THREE.Euler(pitch, yaw, 0, "YXZ"));

        scene.quaternion.copy(quaternion);

        touchPrevX = touchX;
        touchPrevY = touchY;

      }, { passive: false });


      window.addEventListener("touchend", () => {
        touchDragging = false;
      });



      /* ===============================
         Zoom controls: wheel, trackpad pinch, iOS pinch
      =============================== */

      window.addEventListener("wheel", e => {
        e.preventDefault();
        zoomVelocity += e.deltaY * 0.0006;
      }, { passive: false });


      let initialPinchDistance = null;

      function getDistance(touches) {
        return Math.sqrt(
          (touches[0].clientX - touches[1].clientX) ** 2 +
          (touches[0].clientY - touches[1].clientY) ** 2
        );
      }

      window.addEventListener("touchstart", e => {
        if (e.touches.length === 2) {
          initialPinchDistance = getDistance(e.touches);
        }
      }, { passive: false });

      window.addEventListener("touchmove", e => {
        if (e.touches.length === 2 && initialPinchDistance !== null) {

          e.preventDefault();

          const currentDistance = getDistance(e.touches);
          const delta = initialPinchDistance - currentDistance;

          // Add inertia instead of direct zoom
          zoomVelocity += delta * 0.0008;

          initialPinchDistance = currentDistance;
        }
      }, { passive: false });

      window.addEventListener("touchend", e => {
        if (e.touches.length < 2) {
          initialPinchDistance = null;
        }
      });

      /* ===============================
   Generate Compass Ticks (16 divisions)
=============================== */

const tickGroup = document.querySelector(".compass-ticks");

if (tickGroup) {

  for (let i = 0; i < 16; i++) {

    const angle = (i / 16) * Math.PI * 2;

    const innerRadius = i % 4 === 0 ? 30 : 36; // major every 4
    const outerRadius = 44;

    const x1 = 50 + innerRadius * Math.cos(angle);
    const y1 = 50 + innerRadius * Math.sin(angle);

    const x2 = 50 + outerRadius * Math.cos(angle);
    const y2 = 50 + outerRadius * Math.sin(angle);

    const line = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "line"
    );

    line.setAttribute("x1", x1);
    line.setAttribute("y1", y1);
    line.setAttribute("x2", x2);
    line.setAttribute("y2", y2);

    line.setAttribute(
      "class",
      i % 4 === 0 ? "compass-tick major" : "compass-tick"
    );

    tickGroup.appendChild(line);
  }

}



      /* ===============================
         SEARCH MODULE
      =============================== */

      const searchInput = document.getElementById("citySearch");
      const resultsContainer = document.getElementById("searchResults");

      searchInput.addEventListener("input", () => {

        const query = searchInput.value.trim().toLowerCase();

        if (query.length < 2) {
          resultsContainer.style.display = "none";
          return;
        }

        const matches = cities
          .filter(city => city.name.toLowerCase().startsWith(query))
          .slice(0, 5);

        resultsContainer.innerHTML = "";

        matches.forEach(city => {

          const div = document.createElement("div");
          div.className = "searchItem";
          div.textContent = (city.country && city.name !== city.country)
            ? `${city.name}, ${city.country}`
            : city.name;


          div.addEventListener("click", () => {

            focusCity(city);
            resultsContainer.style.display = "none";
            searchInput.value = city.name;

          });

          resultsContainer.appendChild(div);
        });

        resultsContainer.style.display = matches.length ? "block" : "none";
      });

      window.addEventListener("click", (e) => {
        if (!document.getElementById("searchContainer").contains(e.target)) {
          resultsContainer.style.display = "none";
        }
      });


      /* ===============================
         FOCUS CITY ROTATION
      =============================== */

      let targetQuaternion = null;

      function focusCity(city) {

        const index = cities.findIndex(c => c.name === city.name);
        selectedCityIndex = index;

        const phi = (90 - city.lat) * (Math.PI / 180);
        const theta = (city.lon + 180) * (Math.PI / 180);

        const cityAltitude = 0.02; // small offset above surface

        const x = -(radius + cityAltitude) * Math.sin(phi) * Math.cos(theta);
        const z =  (radius + cityAltitude) * Math.sin(phi) * Math.sin(theta);
        const y =  (radius + cityAltitude) * Math.cos(phi);


        const cityVector = new THREE.Vector3(x, y, z).normalize();
        const target = new THREE.Vector3(0, 0, 1);

        targetQuaternion = new THREE.Quaternion()
          .setFromUnitVectors(cityVector, target);

        targetZoom = 2; // auto zoom slightly closer    

        const ringAltitude = 0.03;

        const ringX = -(radius + ringAltitude) * Math.sin(phi) * Math.cos(theta);
        const ringZ =  (radius + ringAltitude) * Math.sin(phi) * Math.sin(theta);
        const ringY =  (radius + ringAltitude) * Math.cos(phi);

        ringGroup.position.set(ringX, ringY, ringZ);
        ringGroup.lookAt(0, 0, 0);
        ringStates.forEach((state, i) => {
          state.progress = 0;
          state.delay = i * ringBurstDelay;
          state.active = true;

          ringMeshes[i].scale.set(1, 1, 1);
          ringMeshes[i].material.opacity = 0;
        });



      }


      // Animation loop
      function animate(){
        requestAnimationFrame(animate);

        if (targetQuaternion) {
          scene.quaternion.slerp(targetQuaternion, 0.08);

        if (scene.quaternion.angleTo(targetQuaternion) < 0.001) {
          scene.quaternion.copy(targetQuaternion);
          targetQuaternion = null;

          // --- Sync yaw/pitch with final quaternion ---
          const syncedEuler = new THREE.Euler()
            .setFromQuaternion(scene.quaternion, "YXZ");

          pitch = syncedEuler.x;
          yaw   = syncedEuler.y;

          glowPulseTime = 0;
          glowPulseActive = true;
        }
        }
        if (!dragging && !targetQuaternion && !isFocused) {

          // Gentle eastward auto-rotation
          const autoSpin = new THREE.Quaternion()
            .setFromAxisAngle(new THREE.Vector3(0,1,0), 0.0002);

          scene.quaternion.multiplyQuaternions(autoSpin, scene.quaternion);


        }


        zoomVelocity *= zoomFriction;
        targetZoom += zoomVelocity;
        targetZoom = Math.max(1.5, Math.min(5, targetZoom));

        const zoomDelta = targetZoom - camera.position.z;

        const easingStrength = 0.08;
        const dynamicEasing = easingStrength * Math.min(Math.abs(zoomDelta) * 2, 1);

        camera.position.z += zoomDelta * dynamicEasing;


        updateCityGlow(); 
        updateHoverLabels();

        // ------------------------------
        // Leader Line Projection
        // ------------------------------
        const panelOpen = document.getElementById("infoPanel")
          .classList.contains("active");
         
        const hoveringDifferentCity =
          hoveredIndex !== null &&
          hoveredIndex !== selectedCityIndex;  

        if (hoveredCityPosition && (!panelOpen || hoveringDifferentCity)) {


          const vector = hoveredCityPosition.clone();
          vector.project(camera);

          const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
          const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;

          updateHoverLine(x, y);

        } else {

          hideHoverLine();

        }        

        // ------------------------------
        // Ring Burst Animation
        // ------------------------------

        if (isFocused && selectedCityIndex !== null) {

          ringStates.forEach((state, i) => {

            if (!state.active) return;

            if (state.delay > 0) {
              state.delay -= ringSpeed;
              return;
            }

            state.progress += ringSpeed;

            const maxScale = ringMultiplierMax;
            const scale = 1 + state.progress * (maxScale - 1);

            ringMeshes[i].scale.set(scale, scale, scale);

            const opacity = Math.pow(1 - state.progress, 1.8);
            ringMeshes[i].material.opacity = opacity;

            if (state.progress >= 1) {
              ringMeshes[i].material.opacity = 0;
              state.active = false;
            }

          });

        } else {

          ringMeshes.forEach(ring => {
            ring.material.opacity = 0;
          });

        }

        if (glowPulseActive) {

          glowPulseTime += 0.03;

          if (glowPulseTime >= 1) {
            glowPulseActive = false;
          }

        }        
        // ------------------------------
        // Earth Twinkle Update (Smooth)
        // ------------------------------

        const earthColorAttr = earthPoints.geometry.attributes.color;

        for (let i = 0; i < earthTwinkleTimers.length; i++) {

          if (earthTwinkleTimers[i] <= 0 && Math.random() < earthTwinkleChance) {
            earthTwinkleTimers[i] = earthTwinkleDuration;
          }

          let brightness = earthBaseBrightness[i];

          if (earthTwinkleTimers[i] > 0) {

            const t = earthTwinkleTimers[i] / earthTwinkleDuration;

            // smooth fade in/out curve
            const fade = Math.sin(t * Math.PI);

            brightness *= (1 - earthTwinkleIntensity * fade);

            earthTwinkleTimers[i] -= 0.016;
          }

          earthColorAttr.setXYZ(i, brightness, brightness, brightness);
        }

        earthColorAttr.needsUpdate = true;

        if (compassSVG) {

          const euler = new THREE.Euler().setFromQuaternion(scene.quaternion);

          compassSVG.style.transform = `rotate(${-euler.y}rad)`;

        }


        renderer.render(scene,camera);
        }

      animate();
    }

    class GeoBoundaryLayer {

      constructor(scene, radius) {
        this.scene = scene;
        this.radius = radius;
        this.group = new THREE.Group();
        this.scene.add(this.group);
      }

      latLonToVector3(lat, lon, altitude = 0.01) {

        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);

        const r = this.radius + altitude;

        const x = -r * Math.sin(phi) * Math.cos(theta);
        const z =  r * Math.sin(phi) * Math.sin(theta);
        const y =  r * Math.cos(phi);

        return new THREE.Vector3(x, y, z);
      }

      loadGeoJSON(geojson) {

        geojson.features.forEach(feature => {

          const geometry = feature.geometry;

          if (geometry.type === "Polygon") {
            this.drawPolygon(geometry.coordinates);
          }

          if (geometry.type === "MultiPolygon") {
            geometry.coordinates.forEach(polygon => {
              this.drawPolygon(polygon);
            });
          }

        });
      }

    drawPolygon(polygon) {

      polygon.forEach(ring => {

        const points = [];

        ring.forEach(coord => {
          const [lon, lat] = coord;
          points.push(this.latLonToVector3(lat, lon));
        });

        const geometry = new THREE.BufferGeometry().setFromPoints(points);

        const material = new THREE.ShaderMaterial({
          transparent: true,
          uniforms: {
            color: { value: new THREE.Color(1.5, 1.5, 1.5) },
            opacity: { value: 0.99 }
          },
          vertexShader: `
            varying float vDot;

            void main() {

              vec4 worldPosition = modelMatrix * vec4(position, 1.0);
              vec3 normal = normalize(worldPosition.xyz);

              vec3 cameraDir = normalize(cameraPosition - worldPosition.xyz);

              vDot = dot(normal, cameraDir);

              gl_Position = projectionMatrix * viewMatrix * worldPosition;
            }
          `,
          fragmentShader: `
            uniform vec3 color;
            uniform float opacity;
            varying float vDot;

            void main() {

              float shade = clamp(vDot, 0.0, 1.0);

              // Stronger contrast curve
              float contrast = pow(shade, 2.0);

              // Darkness level for far side (0 = black)
              float darkness = 0.12;

              float finalShade = mix(darkness, 1.0, contrast);

              gl_FragColor = vec4(color * finalShade, opacity * finalShade);
            }

          `
        });

        const line = new THREE.Line(geometry, material);
        this.group.add(line);

      });
    }


    setVisible(value) {
      this.group.visible = value;
    }

    setColor(color) {
      this.group.children.forEach(child => {
        child.material.uniforms.color.value.set(color);
      });
    }

  }



  </script>
</body>
</html>