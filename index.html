<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Population Globe with Zoom</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: #000;

      font-family: -apple-system, BlinkMacSystemFont,
                   "Segoe UI", Roboto,
                   "Helvetica Neue", Arial,
                   sans-serif;

      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    canvas { display: block; }
    #searchContainer {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 340px;
      z-index: 10;
    }

    #citySearch {
      width: 100%;
      padding: 12px 20px;
      border-radius: 40px;
      border: 1.5px solid rgba(255, 255, 255, 0.9);
      outline: none;
      background: #000;
      color: #fff;
      font-size: 15px;
      letter-spacing: 0.5px;
      box-shadow: 0 0 18px rgba(255,255,255,0.06);
      transition: border 0.2s ease, box-shadow 0.2s ease;
    }

    #citySearch:focus {
      border: 1.5px solid #ffffff;
      box-shadow: 0 0 12px rgba(255,255,255,0.4);
    }

    #searchResults {
      margin-top: 8px;
      background: rgba(0,0,0,0.96);
      border-radius: 14px;
      max-height: 210px; /* ~5 results */
      overflow-y: auto;
      display: none;
      box-shadow: 0 0 15px rgba(255,255,255,0.04);
    }

   .searchItem {
      padding: 10px 14px;
      cursor: pointer;
      color: #fff;
      font-size: 14px;
    }

    .searchItem:hover {
      background: rgba(255,255,255,0.08);
    }

    #cityList {
      display: none;
      position: absolute; top: 5px; right: -500px; width: 250px; max-height: 85vh; overflow-y: auto;
      background: rgba(0,0,0,0.75); color: #fff; padding: 8px; font-size: 10px; border-radius: 8px;
    }
    #cityList ul { list-style: none; padding: 0; margin: 0; }
    #cityList li { margin-bottom: 5px; border-bottom: 1px solid rgba(255,255,255,0.08); padding-bottom: 3px; }
    #cityList li:last-child { border-bottom: none; }
    #infoPanel {
      position: fixed; bottom: -300px; left: 0; width: 100%; height: 260px;
      background: rgba(0,0,0,0.95); color: white; padding: 20px; box-sizing: border-box;
      transition: bottom 0.4s ease; overflow-y: auto; border-top: 2px solid rgba(255,255,255,0.1);
    }
    #infoPanel.active { bottom: 0; }
    #infoPanel a { color: #4da6ff; text-decoration: none; display: block; margin-bottom: 8px; }
    #infoPanel a:hover { text-decoration: underline; }

    #infoPanel button.closePanel {
      position: absolute;
      top: 10px;
      right: 15px;
      background: #444;
      color: #fff;
      border: none;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 12px;
      border-radius: 4px;
    }
    #infoPanel button.closePanel:hover {
       background: #666;
    }

    .cityBubble {
      position: absolute;
      pointer-events: none;
      transform: translate(-50%, -140%);
      transition: opacity 0.2s ease, transform 0.2s ease;
      font-size: 11px;
      color: #fff;
      white-space: nowrap;
    }

    .bubbleContent {
      background: rgba(0, 0, 0, 0.88);
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 6px 10px;
      border-radius: 10px;
      backdrop-filter: blur(6px);
      box-shadow: 0 0 12px rgba(0, 0, 0, 0.5);
    }

    .bubbleTitle {
      font-weight: 600;
      font-size: 12px;
      margin-bottom: 2px;
    }

    .bubbleMeta {
      font-size: 10px;
      opacity: 0.7;
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .bubbleWrapper {
      position: relative;
      display: inline-block;
    }

    .bubbleOutline {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .bubbleRect {
      fill: rgba(0, 0, 0, 0.88);
      stroke: rgba(255, 255, 255, 0.4);
      stroke-width: 1.2;
    }

    .bubbleContent {
      position: relative;
      padding: 6px 12px;
      border-radius: 12px;
      color: #fff;
      white-space: nowrap;
    }

    .cityBubble.hovered .bubbleContent {
      animation: bubblePulse 11s ease-in-out infinite;
    }

    @keyframes electricPulse {
      0% {
        box-shadow:
          0 0 6px rgba(255,255,255,0.08),
          0 0 0px rgba(0,150,255,0);
      }
      35% {
        box-shadow:
          0 0 18px rgba(255,255,255,0.35),
          0 0 28px rgba(0,150,255,0.6);
      }
      70% {
        box-shadow:
          0 0 10px rgba(255,255,255,0.2),
          0 0 14px rgba(0,150,255,0.3);
      }
      100% {
        box-shadow:
          0 0 6px rgba(255,255,255,0.08),
          0 0 0px rgba(0,150,255,0);
      }
    }


/* ===============================
   Compass
=============================== */

#compass {

  position: absolute;
  top: 20px;
  right: 20px;

  width: 56px;
  height: 56px;

  border-radius: 50%;

  backdrop-filter: blur(12px);
  background: rgba(0, 0, 0, 0.65);
  border: 1px solid rgba(255,255,255,0.25);

  display: flex;
  align-items: center;
  justify-content: center;

  cursor: pointer;
  user-select: none;

  z-index: 30;

  transition: transform 0.2s ease;
}

#compass:hover {
  transform: scale(1.08);
}

.compass-svg {
  width: 100%;
  height: 100%;
}

.compass-circle {
  fill: none;
  stroke: rgba(255,255,255,0.5);
  stroke-width: 2;
}

.compass-letter {
  fill: white;
  font-size: 12px;
  font-weight: 600;
  opacity: 0.9;
}

.compass-arrow-line {
  stroke: white;
  stroke-width: 2;
}

.compass-arrow-head {
  fill: red;
}

.compass-tick {
  stroke: rgba(255,255,255,0.6);
  stroke-width: 1;
}

.compass-tick.major {
  stroke-width: 2;
}

#modeWidget {
  position: absolute;
  top: 90px;
  right: 20px;
  width: 140px;
  border-radius: 16px;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(12px);
  border: 1px solid rgba(255,255,255,0.2);
  color: white;
  z-index: 30;
  overflow: hidden;
  transition: height 0.3s ease, width 0.3s ease;
}

#modeWidget.minimized {
  height: 40px;
  width: 70px;
}

#modeHeader {
  padding: 10px;
  font-weight: 600;
  cursor: pointer;
}

#modeOptions {
  display: flex;
  flex-direction: column;
  padding: 8px;
  gap: 6px;
}

#modeOptions button {
  background: rgba(255,255,255,0.08);
  border: none;
  color: white;
  padding: 6px;
  border-radius: 10px;
  cursor: pointer;
}

#modeOptions button.active {
  background: rgba(255,255,255,0.25);
}





  </style>
</head>

<body>
  <div id="cityList"><h3>Geopolitical Cities</h3><ul id="list"></ul></div>
  <div id="infoPanel"><div id="panelContent"></div></div>
  <div id="cityLabels" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;"></div>
  <svg id="uiOverlay"
       style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:5;">
    <line id="hoverLine"
        stroke="white"
        stroke-width="1"
        opacity="0"/>
  </svg>
  <div id="searchContainer">
    <input type="text" id="citySearch" placeholder="Search city..." />
    <div id="searchResults"></div>
  </div>

<!-- Compass Widget -->
<div id="compass">
  <svg class="compass-svg" viewBox="0 0 100 100">
    
    <!-- Outer Ring -->
    <circle cx="50" cy="50" r="46" class="compass-circle" />

    <!-- Tick Marks -->
    <g class="compass-ticks"></g>

    <!-- Cardinal Letters -->
    <text x="50" y="18" text-anchor="middle" class="compass-letter">N</text>
    <text x="50" y="92" text-anchor="middle" class="compass-letter">S</text>
    <text x="8" y="54" text-anchor="middle" class="compass-letter">W</text>
    <text x="92" y="54" text-anchor="middle" class="compass-letter">E</text>

    <!-- Arrow -->
    <line x1="50" y1="50" x2="50" y2="25" class="compass-arrow-line"/>
    <polygon points="50,15 45,25 55,25" class="compass-arrow-head"/>

  </svg>
</div>

<div id="modeWidget" class="expanded">
  <div id="modeHeader">View</div>
  <div id="modeOptions">
    <button id="cityModeBtn">City</button>
    <button id="countryModeBtn" class="active">Country</button>
  </div>
</div>





  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js";

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 3;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);


    const maxTilt = Math.PI / 2.2;

          // ===============================
      // Window Resize Handling
      // ===============================

      window.addEventListener("resize", () => {

        const width = window.innerWidth;
        const height = window.innerHeight;

        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

      });


    const radius = 1;

    // Smooth zoom target
    let targetZoom = camera.position.z;
    let zoomVelocity = 0;
    const zoomFriction = 0.92;


    /* ===============================
       Load Earth texture and initialize
    =============================== */
    const loader = new THREE.TextureLoader();
    const earthTexture = loader.load(
      "https://threejs.org/examples/textures/land_ocean_ice_cloud_2048.jpg",
      () => {

        Promise.all([
          fetch("https://earth-wjr6.onrender.com/api/cities")
            .then(res => res.json()),
          fetch("https://earth-wjr6.onrender.com/api/countries")
            .then(res => res.json())
        ])
          .then(([cities, countries]) => {
            init(cities, countries);
          })
          .catch(err => {
            console.error("Failed to load initial data:", err);
          });

      }
    );



    function init(cities, countries) {
      // Earth points
      const earthPointCount = 10000;
      const earthPositions = [];
      const earthColors = [];
      const earthBaseBrightness = [];

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = earthTexture.image.width;
      canvas.height = earthTexture.image.height;
      ctx.drawImage(earthTexture.image, 0, 0);
      const imageData = ctx.getImageData(0,0,canvas.width,canvas.height).data;

      for(let i=0;i<earthPointCount;i++){
        const u=Math.random(), v=Math.random();
        const theta = 2*Math.PI*u;
        const phi = Math.acos(2*v-1);
        const x = radius*Math.sin(phi)*Math.cos(theta);
        const y = radius*Math.cos(phi);
        const z = radius*Math.sin(phi)*Math.sin(theta);
        earthPositions.push(x,y,z);
        const lon=Math.atan2(z,x), lat=Math.asin(y/radius);
        const uTex=(lon/(2*Math.PI))+0.5;
        const vTex=0.5-(lat/Math.PI);
        const px = Math.floor(uTex*canvas.width), py = Math.floor(vTex*canvas.height);
        const idx=(py*canvas.width+px)*4;
        const r=imageData[idx], g=imageData[idx+1], b=imageData[idx+2];
        const bright = (r+g+b)/3;
        const c = bright>120 ? 0.2 : 1.0;
        earthColors.push(c,c,c);
        earthBaseBrightness.push(c);
      }

      const earthGeo = new THREE.BufferGeometry();
      earthGeo.setAttribute("position", new THREE.Float32BufferAttribute(earthPositions,3));
      earthGeo.setAttribute("color", new THREE.Float32BufferAttribute(earthColors,3));
      const earthMat = new THREE.PointsMaterial({ size:0.006, vertexColors:true, transparent:true, depthWrite:false });
      const earthPoints = new THREE.Points(earthGeo, earthMat);
      scene.add(earthPoints);

            // ------------------------------
      // Earth Twinkle System
      // ------------------------------

      const earthTwinkleChance = 0.04;
      const earthTwinkleDuration = 0.2;
      const earthTwinkleIntensity = 0.6;

      const earthTwinkleTimers = new Array(earthPointCount).fill(0);


      /* ===============================
         FULL CITY LIST GOES HERE
      =============================== */


      // City points
      const citySize = 0.0375;
      const ringBurstDelay = 0.18;
      const ringSpeed = 0.008; 
      const positions = [];
      const ringMultiplierMax = 8;
      const ringStartRadius = 0.005;
      const ringThickness = 0.0001;
      const ringOuterMultiplier = 8;
      const listElement = document.getElementById("list");
      cities.forEach(city=>{
        const {name,lat,lon,country}=city;
        const phi=(90-lat)*(Math.PI/180);
        const theta=(lon+180)*(Math.PI/180);
        const x=-radius*Math.sin(phi)*Math.cos(theta);
        const z= radius*Math.sin(phi)*Math.sin(theta);
        const y= radius*Math.cos(phi);
        positions.push(x,y,z);
        const li=document.createElement("li");
        li.textContent = (country && name !== country)
          ? `${name}, ${country}`
          : name;
        listElement.appendChild(li);
      });

      const cityGeo=new THREE.BufferGeometry();
      cityGeo.setAttribute("position", new THREE.Float32BufferAttribute(positions,3));

      function createGlowTexture(){
        const size=128;
        const glowCanvas=document.createElement("canvas");
        glowCanvas.width=size; glowCanvas.height=size;
        const ctx=glowCanvas.getContext("2d");
        const outerRadius = size * 0.15;
        const grad=ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
        grad.addColorStop(0,"rgba(255,200,120,1)");
        grad.addColorStop(0.4,"rgba(255,140,40,0.7)");
        grad.addColorStop(0.8,"rgba(255,80,20,0.3)");
        grad.addColorStop(1,"rgba(255,80,20,0)");
        ctx.fillStyle=grad; ctx.fillRect(0,0,size,size);
        return new THREE.CanvasTexture(glowCanvas);
      }

      const glowTexture=createGlowTexture();
      const cityMat=new THREE.PointsMaterial({
        size:citySize,
        sizeAttenuation: true,
        map:glowTexture,
        transparent:true,
        blending:THREE.AdditiveBlending,
        depthWrite:false
      });
      const cityPoints=new THREE.Points(cityGeo,cityMat);
      scene.add(cityPoints);

            // ===============================
      // Country Points
      // ===============================

      const countryPositions = [];

      countries.forEach(country => {

        const { lat, lon } = country;

        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);

        const x = -radius * Math.sin(phi) * Math.cos(theta);
        const z =  radius * Math.sin(phi) * Math.sin(theta);
        const y =  radius * Math.cos(phi);

        countryPositions.push(x, y, z);
      });

      const countryGeo = new THREE.BufferGeometry();
      countryGeo.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(countryPositions, 3)
      );

      const countryMat = new THREE.PointsMaterial({
        size: citySize * 1.6,
        sizeAttenuation: true,
        map: glowTexture,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        opacity: 1
      });

      const countryPoints = new THREE.Points(countryGeo, countryMat);
      scene.add(countryPoints);


            // ===============================
      // Selection Ring Burst
      // ===============================


      const ringGroup = new THREE.Group();
      scene.add(ringGroup);

      const ringCount = 3;
      const ringMeshes = [];
      const ringStates = [];

      for (let i = 0; i < ringCount; i++) {

        const ringGeo = new THREE.RingGeometry(
          ringStartRadius,
          ringStartRadius + ringThickness * ringOuterMultiplier,
          64
        );


        const ringMat = new THREE.MeshBasicMaterial({
          color: new THREE.Color(1.0, 0.6, 0.25),
          transparent: true,
          opacity: 0,
          side: THREE.DoubleSide,
          depthWrite: false,
          blending: THREE.NormalBlending
        });


        const ring = new THREE.Mesh(ringGeo, ringMat);


        ringGroup.add(ring);
        ringMeshes.push(ring);

        ringStates.push({
          progress: 0,
          delay: i * ringBurstDelay,
          active: false
        });
      }
     

      /* >>>>> INSERTED: GEO BOUNDARY LOADER START */

      const boundaryLayer = new GeoBoundaryLayer(scene, radius);

      fetch("custom.geo.json")
        .then(res => res.json())
        .then(data => {
          boundaryLayer.loadGeoJSON(data);
        });

      // ------------------------------
      // Utility: check if city is facing the camera
      // ------------------------------

      function isCityVisible(pointPos, camera) {
 
        const pointVector = pointPos.clone().normalize();


        const cameraDir = new THREE.Vector3();
        camera.getWorldDirection(cameraDir).normalize();

        const dot = cameraDir.dot(pointVector);
        return dot < 0;
      }


      function updateNodeGlow() {

        const activePoints = currentViewMode === "country"
          ? countryPoints
          : cityPoints;

        const activeMaterial = currentViewMode === "country"
          ? countryMat
          : cityMat;

        const cameraDir = new THREE.Vector3();
        camera.getWorldDirection(cameraDir).normalize();

        const positionsAttr =
          activePoints.geometry.attributes.position;

        const count = positionsAttr.count;

        if (!activePoints.geometry.attributes.color) {

          const colors = new Float32Array(count * 3);

          activePoints.geometry.setAttribute(
            "color",
            new THREE.BufferAttribute(colors, 3)
          );

          activeMaterial.vertexColors = true;

        }

        const colors =
          activePoints.geometry.attributes.color;

        for (let i = 0; i < count; i++) {

          const nodePos = new THREE.Vector3();

          nodePos.fromBufferAttribute(positionsAttr, i);
          nodePos.applyMatrix4(activePoints.matrixWorld);
          nodePos.normalize();

          let dot = -cameraDir.dot(nodePos);
          let normalized = (dot + 1) / 2;

          const minGlow = 0.15;

          let glow =
            minGlow +
            (1 - minGlow) * Math.pow(normalized, 2.5);

          if (glowPulseActive && i === selectedNodeIndex) {
            const pulse =
              1 + 0.4 * Math.sin(glowPulseTime * Math.PI);
            glow *= pulse;
          }

          colors.setXYZ(
            i,
            glow,
            glow * 0.6,
            glow * 0.25
          );

        }

        colors.needsUpdate = true;

      }



      const cityLabelsContainer = document.getElementById("cityLabels");
      const cityLabels = cities.map(city => {

        const div = document.createElement("div");

        div.innerHTML = `
          <div class="bubbleWrapper">

            <svg class="bubbleOutline">
              <rect class="bubbleRect"
                    x="0"
                    y="0"
                    rx="12"
                    ry="12"
                    width="100%"
                    height="100%" />
            </svg>

            <div class="bubbleContent">
              <div class="bubbleTitle">${city.name}</div>
              <div class="bubbleMeta">
                <span class="storyCount">0 stories</span>
              </div>
            </div>

          </div>
        `;


        div.className = "cityBubble";
        div.style.position = "absolute";
        div.style.pointerEvents = "none";
        div.style.opacity = 0;
        div.style.transition = "opacity 0.2s";

        cityLabelsContainer.appendChild(div);

        return div;
      });

      
      const countryLabels = countries.map(country => {

        const div = document.createElement("div");

        div.innerHTML = `
          <div class="bubbleWrapper">

            <svg class="bubbleOutline">
              <rect class="bubbleRect"
                    x="0"
                    y="0"
                    rx="12"
                    ry="12"
                    width="100%"
                    height="100%" />
            </svg>

            <div class="bubbleContent">
              <div class="bubbleTitle">${country.name}</div>
              <div class="bubbleMeta">
                <span class="storyCount">0 stories</span>
              </div>
            </div>

          </div>
        `;

        div.className = "cityBubble";
        div.style.position = "absolute";
        div.style.pointerEvents = "none";
        div.style.opacity = 0;
        div.style.transition = "opacity 0.2s";

        cityLabelsContainer.appendChild(div);

        return div;

      });

      

      

      const hoverMouse = new THREE.Vector2();
      let hoveredIndex = null;
      let selectedNodeIndex = null;
      let isFocused = false;
      let hoveredCityPosition = null;
      let timeInterval = null;
      const compassSVG = document.querySelector(".compass-svg");

      // ===============================
      // VIEW MODE TOGGLE
      // ===============================

      let currentViewMode = "country";
      setActiveMode("country");

      cityMat.opacity = 0.15;
      countryMat.opacity = 1.0;


      

      const widget = document.getElementById("modeWidget");
      const header = document.getElementById("modeHeader");

      header.addEventListener("click", () => {
        widget.classList.toggle("minimized");
      });

      document.getElementById("cityModeBtn").addEventListener("click", () => {

        currentViewMode = "city";
        setActiveMode("city");

        targetCityOpacity = 1.0;
        targetCountryOpacity = 0.15;

      });

      document.getElementById("countryModeBtn").addEventListener("click", () => {

        currentViewMode = "country";
        setActiveMode("country");

        targetCityOpacity = 0.15;
        targetCountryOpacity = 1.0;

      });

      function setActiveMode(mode) {

        document.getElementById("cityModeBtn").classList.remove("active");
        document.getElementById("countryModeBtn").classList.remove("active");

        if (mode === "city") {
          document.getElementById("cityModeBtn").classList.add("active");
        } else {
          document.getElementById("countryModeBtn").classList.add("active");
        }

      }      

      



      let glowPulseTime = 0;
      let glowPulseActive = false;

      const compass = document.getElementById("compass");

      compass.addEventListener("click", () => {

        const currentEuler = new THREE.Euler()
          .setFromQuaternion(scene.quaternion, "YXZ");

        const targetEuler = new THREE.Euler(
          0,                 // remove tilt
          currentEuler.y,    // preserve longitude
          0,
          "YXZ"
        );

        targetQuaternion = new THREE.Quaternion()
          .setFromEuler(targetEuler);

        isFocused = false;
        selectedNodeIndex = null;

      });




      window.addEventListener("mousemove", (event) => {
          hoverMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          hoverMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      });

      function updateHoverLabels() {

        raycaster.setFromCamera(hoverMouse, camera);

        const activePoints = currentViewMode === "country"
          ? countryPoints
          : cityPoints;

        const activeData = currentViewMode === "country"
          ? countries
          : cities;

        const activeLabels = currentViewMode === "country"
          ? countryLabels
          : cityLabels;

        const activePositions = currentViewMode === "country"
          ? countryPositions
          : positions;

        const intersects = raycaster.intersectObject(activePoints);

        hoveredIndex = null;
        hoveredCityPosition = null;

        const infoPanel = document.getElementById("infoPanel");
        const panelOpen = infoPanel.classList.contains("active");

        // ------------------------------
        // Hover Detection
        // ------------------------------

        if (intersects.length > 0) {

          const index = intersects[0].index;

          if (panelOpen && index === selectedNodeIndex) {
            return;
          }

          const nodePos = new THREE.Vector3();

          nodePos.fromBufferAttribute(
            activePoints.geometry.attributes.position,
            index
          );

          nodePos.applyMatrix4(activePoints.matrixWorld);

          if (isCityVisible(nodePos, camera)) {

            hoveredIndex = index;
            hoveredCityPosition = nodePos.clone();

          }

        }

        // ------------------------------
        // Label Rendering
        // ------------------------------

        activeData.forEach((item, i) => {

          const label = activeLabels[i];
          if (!label) return;

          const pos = new THREE.Vector3(
            activePositions[i * 3],
            activePositions[i * 3 + 1],
            activePositions[i * 3 + 2]
          );

          pos.applyMatrix4(activePoints.matrixWorld);

          const projected = pos.clone().project(camera);

          const x = (projected.x + 1) / 2 * window.innerWidth;
          const y = (-projected.y + 1) / 2 * window.innerHeight;

          label.style.left = `${x}px`;
          label.style.top  = `${y}px`;

          const isHovered  = (i === hoveredIndex);
          const isSelected = (i === selectedNodeIndex);

          const shouldShow =
            (isHovered) ||
            (!panelOpen && isSelected);

          if (isSelected) {
            label.classList.add("focused");
          } else {
            label.classList.remove("focused");
          }

          if (isHovered) {
            label.classList.add("hovered");
          } else {
            label.classList.remove("hovered");
          }

          if (shouldShow) {

            const storyCountEl = label.querySelector(".storyCount");

            if (storyCountEl) {
              storyCountEl.textContent =
                `${item.storyCount || 0} stories`;
            }

            label.style.opacity = 1;
            label.style.transform =
              "translate(-50%, -160%) scale(1)";

            if (isHovered || isSelected) {
              triggerBubbleTyping(i);
            }

          } else {

            label.style.opacity = 0;
            label.style.transform =
              "translate(-50%, -140%) scale(0.95)";

            const title = label.querySelector(".bubbleTitle");

            if (title) {

              title._typingActive = false;

              if (title._typingTimer) {
                clearTimeout(title._typingTimer);
                title._typingTimer = null;
              }

              title.textContent = item.name;
            }

          }

        });

      }


            // ------------------------------
      // Bubble Perimeter Trace
      // ------------------------------

      function triggerBubbleTrace(index, onComplete) {

        const activeLabels = currentViewMode === "country"
          ? countryLabels
          : cityLabels;

        const bubble = activeLabels[index];
        if (!bubble) return;

        const content = bubble.querySelector(".bubbleContent");
        if (!content) return;

        content.classList.remove("trace");
        void content.offsetWidth; // force reflow to restart animation
        content.classList.add("trace");

        setTimeout(() => {

          if (onComplete) {
            onComplete();
          }

        }, 500);

      }


      

      function triggerBubbleTyping(index) {

        const activeData = currentViewMode === "country"
          ? countries
          : cities;

        const activeLabels = currentViewMode === "country"
          ? countryLabels
          : cityLabels;

        const bubble = activeLabels[index];
        if (!bubble) return;

        const title = bubble.querySelector(".bubbleTitle");
        if (!title) return;

        const fullText = activeData[index].name;

        if (title.textContent === fullText) return;
        if (title._typingActive) return;

        if (title._typingTimer) {
          clearTimeout(title._typingTimer);
          title._typingTimer = null;
        }

        title.textContent = "";
        title._typingActive = true;
        title.classList.add("typing");

        let charIndex = 0;
        const typingSpeed = 22.5;

        function type() {

          if (charIndex < fullText.length) {

            title.textContent += fullText.charAt(charIndex);
            charIndex++;

            title._typingTimer = setTimeout(type, typingSpeed);

          } else {

            title._typingActive = false;
            title._typingTimer = null;
            title.classList.remove("typing");

          }

        }

        type();

      }



      // ------------------------------
      // Electric Bubble Timer
      // ------------------------------

      function triggerElectricPulse() {

        const activeLabels = currentViewMode === "country"
          ? countryLabels
          : cityLabels;

        activeLabels.forEach(label => {

          if (label.style.opacity === "1") {

            label.classList.remove("electric");
            void label.offsetWidth;
            label.classList.add("electric");

          }

        });

      }


      setInterval(() => {

        triggerElectricPulse();

      }, 3000);




      // Raycaster for node clicks

      const raycaster=new THREE.Raycaster();
      raycaster.params.Points.threshold=0.02;
      const mouse=new THREE.Vector2();

      window.addEventListener("click",event=>{

        mouse.x=(event.clientX/window.innerWidth)*2-1;
        mouse.y=-(event.clientY/window.innerHeight)*2+1;

        raycaster.setFromCamera(mouse,camera);

        const activePoints = currentViewMode === "country"
          ? countryPoints
          : cityPoints;

        const activeData = currentViewMode === "country"
          ? countries
          : cities;

        const intersects=raycaster.intersectObject(activePoints);

        if(intersects.length>0){

          const index=intersects[0].index;

          const nodePos = new THREE.Vector3();
          nodePos.fromBufferAttribute(
            activePoints.geometry.attributes.position,
            index
          );
          nodePos.applyMatrix4(activePoints.matrixWorld);

          if (isCityVisible(nodePos, camera)) {

            selectedNodeIndex = index;
            isFocused = true;

            if (currentViewMode === "country") {

              focusCountry(activeData[index]);
              openCountryPanel(activeData[index]);

            } else {

              focusCity(activeData[index]);
              openCityPanel(activeData[index]);

            }

          }

        }

      });

      


      /* ===============================
         iOS TOUCH NODE SELECTION
      =============================== */

      window.addEventListener("touchstart", (event) => {

        if (event.touches.length !== 1) return;

        const touch = event.touches[0];

        mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        const activePoints = currentViewMode === "country"
          ? countryPoints
          : cityPoints;

        const activeData = currentViewMode === "country"
          ? countries
          : cities;

        const intersects = raycaster.intersectObject(activePoints);

        if (intersects.length > 0) {

          const index = intersects[0].index;

          const nodePos = new THREE.Vector3();
          nodePos.fromBufferAttribute(
            activePoints.geometry.attributes.position,
            index
          );
          nodePos.applyMatrix4(activePoints.matrixWorld);

          if (isCityVisible(nodePos, camera)) {

            selectedNodeIndex = index;
            isFocused = true;

            if (currentViewMode === "country") {

              focusCountry(activeData[index]);
              openCountryPanel(activeData[index]);

            } else {

              focusCity(activeData[index]);
              openCityPanel(activeData[index]);

            }

          }

        }

      }, { passive: true });


            // ------------------------------
      // Leader Line Helpers
      // ------------------------------

      // ------------------------------
      // Leader Line Helpers
      // ------------------------------

      function updateHoverLine(x, y) {

        const line = document.getElementById("hoverLine");
        if (!line) return;

        if (hoveredIndex === null) {

          line.style.opacity = "0";
          return;

        }

        const activeLabels = currentViewMode === "country"
          ? countryLabels
          : cityLabels;

        const bubble = activeLabels[hoveredIndex];

        if (!bubble) {

          line.style.opacity = "0";
          return;

        }


        const rect = bubble.getBoundingClientRect();

        const bubbleX = rect.left + rect.width / 2;
        const bubbleY = rect.bottom;

        line.setAttribute("x1", x);
        line.setAttribute("y1", y);
        line.setAttribute("x2", bubbleX);
        line.setAttribute("y2", bubbleY);

        line.style.opacity = "0.6";
      }

      function hideHoverLine() {

        const line = document.getElementById("hoverLine");
        if (line) {
          line.style.opacity = "0";
        }

      }


        

      function openCityPanel(city){

        const panel = document.getElementById("infoPanel");

        const showCountry =
          city.country &&
          city.name.toLowerCase() !== city.country.toLowerCase();

        panel.innerHTML = `
          <button class="closePanel">✕</button>

          <div style="
            display:flex;
            justify-content:space-between;
            align-items:center;
            margin-top:4px;
          ">

            <div>
              <h2 style="margin:0;">${city.name}</h2>
              ${showCountry
                ? `<h4 style="margin:2px 0 0 0;opacity:0.7;">
                    ${city.country}
                   </h4>`
                : ""
              }
            </div>

            <div id="localTime" style="
              font-size:14px;
              opacity:0.85;
              white-space:nowrap;
            "></div>

          </div>

          <div id="articlesContainer"
               style="margin-top:12px;font-size:13px;">
            Loading articles...
          </div>
        `;

        panel.classList.add("active");

        setTimeout(() => {
          targetZoom = 1.7;
        }, 250);

        // ------------------------------
        // FETCH CITY ARTICLES ONLY
        // ------------------------------

        const endpoint =
          `/api/news/city/${city.id}`;

        fetch(`https://earth-wjr6.onrender.com${endpoint}`)
          .then(res => res.json())
          .then(articles => {

            const container =
              document.getElementById("articlesContainer");

            if (!articles.length) {
              container.innerHTML =
                "<p>No recent articles.</p>";
              return;
            }

            container.innerHTML =
              articles.map(article => `
                <div style="
                  margin-bottom:14px;
                  border-bottom:1px solid rgba(255,255,255,0.1);
                  padding-bottom:8px;
                ">

                  <a href="${article.url}"
                     target="_blank"
                     style="color:#4da6ff;">
                    <strong>${article.title}</strong>
                  </a>

                  <div style="
                    font-size:11px;
                    opacity:0.6;
                    margin-top:4px;
                  ">
                    ${article.source_name} • 
                    ${new Date(article.published_at)
                      .toLocaleDateString()}
                  </div>

                  <p style="margin-top:6px;">
                    ${article.summary || ""}
                  </p>

                </div>
              `).join("");

          })
          .catch(err => {

            console.error("Article load error:", err);

            document.getElementById("articlesContainer").innerHTML =
              "<p>Failed to load articles.</p>";

          });

        // ------------------------------
        // LOCAL TIME
        // ------------------------------

        const timeElement =
          document.getElementById("localTime");

        function updateLocalTime(){

          const nowUTC = new Date();

          const offsetHours = city.lon / 15;

          const localTime = new Date(
            nowUTC.getTime() +
            offsetHours * 60 * 60 * 1000
          );

          const formatted =
            localTime.toLocaleTimeString([], {
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit"
            });

          timeElement.textContent =
            ` ${formatted}`;

        }

        updateLocalTime();

        if(timeInterval)
          clearInterval(timeInterval);

        timeInterval =
          setInterval(updateLocalTime, 1000);

        const closeBtn =
          panel.querySelector(".closePanel");

        closeBtn.addEventListener("click", () => {

          panel.classList.remove("active");

          clearInterval(timeInterval);
          timeInterval = null;

        });

      }

      function openCountryPanel(country){

        const panel = document.getElementById("infoPanel");

        panel.innerHTML = `
          <button class="closePanel">✕</button>

          <div style="
            display:flex;
            justify-content:space-between;
            align-items:center;
            margin-top:4px;
          ">

            <div>
              <h2 style="margin:0;">${country.name}</h2>
            </div>

          </div>

          <div id="articlesContainer"
               style="margin-top:12px;font-size:13px;">
            Loading articles...
          </div>
        `;

        panel.classList.add("active");

        setTimeout(() => {
          targetZoom = 1.7;
        }, 250);

        const endpoint =
          `/api/news/country/${country.id}`;

        fetch(`https://earth-wjr6.onrender.com${endpoint}`)
          .then(res => res.json())
          .then(articles => {

            const container =
              document.getElementById("articlesContainer");

            if (!articles.length) {
              container.innerHTML =
                "<p>No recent articles.</p>";
              return;
            }

            container.innerHTML =
              articles.map(article => `
                <div style="
                  margin-bottom:14px;
                  border-bottom:1px solid rgba(255,255,255,0.1);
                  padding-bottom:8px;
                ">
                  <a href="${article.url}"
                     target="_blank"
                     style="color:#4da6ff;">
                    <strong>${article.title}</strong>
                  </a>

                  <div style="
                    font-size:11px;
                    opacity:0.6;
                    margin-top:4px;
                  ">
                    ${article.source_name} • 
                    ${new Date(article.published_at)
                      .toLocaleDateString()}
                  </div>

                  <p style="margin-top:6px;">
                    ${article.summary || ""}
                  </p>
                </div>
              `).join("");

          })
          .catch(err => {

            console.error("Country article load error:", err);

            document.getElementById("articlesContainer").innerHTML =
              "<p>Failed to load articles.</p>";

          });

        const closeBtn =
          panel.querySelector(".closePanel");

        closeBtn.addEventListener("click", () => {
          panel.classList.remove("active");
        });

      }


      window.addEventListener("keydown",(e)=>{
        if(e.key==="Escape"){
          document.getElementById("infoPanel").classList.remove("active");
          clearInterval(timeInterval);
          timeInterval = null;
        }
      });


      // Drag rotation (stable north-oriented, no pole flip)
      let dragging=false, prevX=0, prevY=0;
      const upAxis = new THREE.Vector3(0,1,0);

      window.addEventListener("mousedown",e=>{
        dragging=true; 
        prevX=e.clientX; 
        prevY=e.clientY;
        selectedNodeIndex = null;
        isFocused = false; 
      });

      window.addEventListener("mouseup",()=>dragging=false);

      window.addEventListener("mousemove", e=>{
        if(!dragging) return;

        const deltaX = (e.clientX - prevX) * 0.005;
        const deltaY = (e.clientY - prevY) * 0.005;

        // --- Horizontal rotation (always around world north axis) ---
        const qY = new THREE.Quaternion()
          .setFromAxisAngle(upAxis, deltaX);

        scene.quaternion.premultiply(qY);

        // --- Vertical rotation (around current right vector) ---
        const rightAxis = new THREE.Vector3(1,0,0)
          .applyQuaternion(scene.quaternion)
          .normalize();

        const qX = new THREE.Quaternion()
          .setFromAxisAngle(rightAxis, deltaY);

        scene.quaternion.premultiply(qX);

        // --- Clamp tilt to prevent pole flip ---
        const euler = new THREE.Euler()
          .setFromQuaternion(scene.quaternion, "YXZ");

        const maxTilt = Math.PI / 2.3;
        euler.x = Math.max(-maxTilt, Math.min(maxTilt, euler.x));

        scene.quaternion.setFromEuler(euler);

        prevX = e.clientX;
        prevY = e.clientY;
      });


// ===============================
// iOS Single-Finger Drag Rotation
// ===============================

      let touchDragging = false;
      let touchPrevX = 0;
      let touchPrevY = 0;
      
      window.addEventListener("touchstart", (e) => {  
        if (e.touches.length === 1) {
          touchDragging = true;
          touchPrevX = e.touches[0].clientX;
          touchPrevY = e.touches[0].clientY;
          selectedNodeIndex = null;
          isFocused = false;
        }  
      }, {passive: false });

      window.addEventListener("touchmove", (e) => {
        if (!touchDragging || e.touches.length !== 1) return;
        e.preventDefault();

        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;

        const deltaX = (touchX - touchPrevX) * 0.005;
        const deltaY = (touchY - touchPrevY) * 0.005;

        // Horizontal rotation (around world north axis)
        scene.quaternion.premultiply(
          new THREE.Quaternion().setFromAxisAngle(upAxis, deltaX)
        );

        // Vertical rotation (around current right axis)
        const rightAxis = new THREE.Vector3(1,0,0)
          .applyQuaternion(scene.quaternion)
          .normalize();

        scene.quaternion.premultiply(
          new THREE.Quaternion().setFromAxisAngle(rightAxis, deltaY)
        );

        // Clamp tilt to prevent pole flip
        const euler = new THREE.Euler()
          .setFromQuaternion(scene.quaternion, "YXZ");

        const maxTilt = Math.PI / 2.3;
        euler.x = Math.max(-maxTilt, Math.min(maxTilt, euler.x));

        scene.quaternion.setFromEuler(euler);



        touchPrevX = touchX;
        touchPrevY = touchY;

      }, { passive: false });


      window.addEventListener("touchend", () => {
        touchDragging = false;
      });



      /* ===============================
         Zoom controls: wheel, trackpad pinch, iOS pinch
      =============================== */

      window.addEventListener("wheel", e => {
        e.preventDefault();
        zoomVelocity += e.deltaY * 0.0006;
      }, { passive: false });


      let initialPinchDistance = null;

      function getDistance(touches) {
        return Math.sqrt(
          (touches[0].clientX - touches[1].clientX) ** 2 +
          (touches[0].clientY - touches[1].clientY) ** 2
        );
      }

      window.addEventListener("touchstart", e => {
        if (e.touches.length === 2) {
          initialPinchDistance = getDistance(e.touches);
        }
      }, { passive: false });

      window.addEventListener("touchmove", e => {
        if (e.touches.length === 2 && initialPinchDistance !== null) {

          e.preventDefault();

          const currentDistance = getDistance(e.touches);
          const delta = initialPinchDistance - currentDistance;

          // Add inertia instead of direct zoom
          zoomVelocity += delta * 0.0008;

          initialPinchDistance = currentDistance;
        }
      }, { passive: false });

      window.addEventListener("touchend", e => {
        if (e.touches.length < 2) {
          initialPinchDistance = null;
        }
      });

      /* ===============================
   Generate Compass Ticks (16 divisions)
=============================== */

const tickGroup = document.querySelector(".compass-ticks");

if (tickGroup) {

  for (let i = 0; i < 16; i++) {

    const angle = (i / 16) * Math.PI * 2;

    const innerRadius = i % 4 === 0 ? 30 : 36; // major every 4
    const outerRadius = 44;

    const x1 = 50 + innerRadius * Math.cos(angle);
    const y1 = 50 + innerRadius * Math.sin(angle);

    const x2 = 50 + outerRadius * Math.cos(angle);
    const y2 = 50 + outerRadius * Math.sin(angle);

    const line = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "line"
    );

    line.setAttribute("x1", x1);
    line.setAttribute("y1", y1);
    line.setAttribute("x2", x2);
    line.setAttribute("y2", y2);

    line.setAttribute(
      "class",
      i % 4 === 0 ? "compass-tick major" : "compass-tick"
    );

    tickGroup.appendChild(line);
  }

}



      /* ===============================
         SEARCH MODULE
      =============================== */

      const searchInput = document.getElementById("citySearch");
      const resultsContainer = document.getElementById("searchResults");

      searchInput.addEventListener("input", () => {

        const query = searchInput.value.trim().toLowerCase();

        if (query.length < 2) {
          resultsContainer.style.display = "none";
          return;
        }

        const matches = cities
          .filter(city => city.name.toLowerCase().startsWith(query))
          .slice(0, 5);

        resultsContainer.innerHTML = "";

        matches.forEach(city => {

          const div = document.createElement("div");
          div.className = "searchItem";
          div.textContent = (city.country && city.name !== city.country)
            ? `${city.name}, ${city.country}`
            : city.name;


          div.addEventListener("click", () => {

            focusCity(city);
            resultsContainer.style.display = "none";
            searchInput.value = city.name;

          });

          resultsContainer.appendChild(div);
        });

        resultsContainer.style.display = matches.length ? "block" : "none";
      });

      window.addEventListener("click", (e) => {
        if (!document.getElementById("searchContainer").contains(e.target)) {
          resultsContainer.style.display = "none";
        }
      });


      /* ===============================
         FOCUS CITY ROTATION
      =============================== */

      let targetQuaternion = null;

      function focusCity(city) {

        const index = cities.findIndex(c => c.name === city.name);
        selectedNodeIndex = index;

        const phi = (90 - city.lat) * (Math.PI / 180);
        const theta = (city.lon + 180) * (Math.PI / 180);

        const cityAltitude = 0.02; // small offset above surface

        const x = -(radius + cityAltitude) * Math.sin(phi) * Math.cos(theta);
        const z =  (radius + cityAltitude) * Math.sin(phi) * Math.sin(theta);
        const y =  (radius + cityAltitude) * Math.cos(phi);


        const cityVector = new THREE.Vector3(x, y, z).normalize();
        const target = new THREE.Vector3(0, 0, 1);

        targetQuaternion = new THREE.Quaternion()
          .setFromUnitVectors(cityVector, target);

        targetZoom = 2; // auto zoom slightly closer    

        const ringAltitude = 0.03;

        const ringX = -(radius + ringAltitude) * Math.sin(phi) * Math.cos(theta);
        const ringZ =  (radius + ringAltitude) * Math.sin(phi) * Math.sin(theta);
        const ringY =  (radius + ringAltitude) * Math.cos(phi);

        ringGroup.position.set(ringX, ringY, ringZ);
        ringGroup.lookAt(0, 0, 0);
        ringStates.forEach((state, i) => {
          state.progress = 0;
          state.delay = i * ringBurstDelay;
          state.active = true;

          ringMeshes[i].scale.set(1, 1, 1);
          ringMeshes[i].material.opacity = 0;
        });



      }

      function focusCountry(country) {

        const index = countries.findIndex(
          c => c.name === country.name
        );

        selectedNodeIndex = index;

        const phi = (90 - country.lat) * (Math.PI / 180);
        const theta = (country.lon + 180) * (Math.PI / 180);

        const altitude = 0.02;

        const x = -(radius + altitude) * Math.sin(phi) * Math.cos(theta);
        const z =  (radius + altitude) * Math.sin(phi) * Math.sin(theta);
        const y =  (radius + altitude) * Math.cos(phi);

        const countryVector =
          new THREE.Vector3(x, y, z).normalize();

        const target = new THREE.Vector3(0, 0, 1);

        targetQuaternion =
          new THREE.Quaternion()
            .setFromUnitVectors(countryVector, target);

        targetZoom = 2;

        // Ring placement
        const ringAltitude = 0.03;

        const ringX = -(radius + ringAltitude) * Math.sin(phi) * Math.cos(theta);
        const ringZ =  (radius + ringAltitude) * Math.sin(phi) * Math.sin(theta);
        const ringY =  (radius + ringAltitude) * Math.cos(phi);

        ringGroup.position.set(ringX, ringY, ringZ);
        ringGroup.lookAt(0, 0, 0);

        ringStates.forEach((state, i) => {

          state.progress = 0;
          state.delay = i * ringBurstDelay;
          state.active = true;

          ringMeshes[i].scale.set(1, 1, 1);
          ringMeshes[i].material.opacity = 0;

        });

      }



      let targetCityOpacity = 0.15;
      let targetCountryOpacity = 1.0;



      // Animation loop
      function animate(){
        requestAnimationFrame(animate);

        if (targetQuaternion) {
          scene.quaternion.slerp(targetQuaternion, 0.08);

        if (scene.quaternion.angleTo(targetQuaternion) < 0.001) {
          scene.quaternion.copy(targetQuaternion);
          targetQuaternion = null;

          // --- Sync yaw/pitch with final quaternion ---
          const syncedEuler = new THREE.Euler()
            .setFromQuaternion(scene.quaternion, "YXZ");



          glowPulseTime = 0;
          glowPulseActive = true;
        }
        }
        if (!dragging && !targetQuaternion && !isFocused) {

          // Gentle eastward auto-rotation
          const autoSpin = new THREE.Quaternion()
            .setFromAxisAngle(new THREE.Vector3(0,1,0), 0.0002);

          scene.quaternion.multiplyQuaternions(autoSpin, scene.quaternion);


        }


        zoomVelocity *= zoomFriction;
        targetZoom += zoomVelocity;
        targetZoom = Math.max(1.5, Math.min(5, targetZoom));

        const zoomDelta = targetZoom - camera.position.z;

        const easingStrength = 0.08;
        const dynamicEasing = easingStrength * Math.min(Math.abs(zoomDelta) * 2, 1);

        camera.position.z += zoomDelta * dynamicEasing;


        updateNodeGlow(); 
        updateHoverLabels();

        // ------------------------------
        // Leader Line Projection
        // ------------------------------
        const panelOpen = document.getElementById("infoPanel")
          .classList.contains("active");
         
        const hoveringDifferentCity =
          hoveredIndex !== null &&
          hoveredIndex !== selectedNodeIndex;  

        if (hoveredCityPosition && (!panelOpen || hoveringDifferentCity)) {


          const vector = hoveredCityPosition.clone();
          vector.project(camera);

          const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
          const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;

          updateHoverLine(x, y);

        } else {

          hideHoverLine();

        }        

        // ------------------------------
        // Ring Burst Animation
        // ------------------------------

        if (isFocused && selectedNodeIndex !== null) {

          ringStates.forEach((state, i) => {

            if (!state.active) return;

            if (state.delay > 0) {
              state.delay -= ringSpeed;
              return;
            }

            state.progress += ringSpeed;

            const maxScale = ringMultiplierMax;
            const scale = 1 + state.progress * (maxScale - 1);

            ringMeshes[i].scale.set(scale, scale, scale);

            const opacity = Math.pow(1 - state.progress, 1.8);
            ringMeshes[i].material.opacity = opacity;

            if (state.progress >= 1) {
              ringMeshes[i].material.opacity = 0;
              state.active = false;
            }

          });

        } else {

          ringMeshes.forEach(ring => {
            ring.material.opacity = 0;
          });

        }

        if (glowPulseActive) {

          glowPulseTime += 0.03;

          if (glowPulseTime >= 1) {
            glowPulseActive = false;
          }

        }        
        // ------------------------------
        // Earth Twinkle Update (Smooth)
        // ------------------------------

        const earthColorAttr = earthPoints.geometry.attributes.color;

        for (let i = 0; i < earthTwinkleTimers.length; i++) {

          if (earthTwinkleTimers[i] <= 0 && Math.random() < earthTwinkleChance) {
            earthTwinkleTimers[i] = earthTwinkleDuration;
          }

          let brightness = earthBaseBrightness[i];

          if (earthTwinkleTimers[i] > 0) {

            const t = earthTwinkleTimers[i] / earthTwinkleDuration;

            // smooth fade in/out curve
            const fade = Math.sin(t * Math.PI);

            brightness *= (1 - earthTwinkleIntensity * fade);

            earthTwinkleTimers[i] -= 0.016;
          }

          earthColorAttr.setXYZ(i, brightness, brightness, brightness);
        }

        earthColorAttr.needsUpdate = true;

        if (compassSVG) {

          const euler = new THREE.Euler().setFromQuaternion(scene.quaternion);

          compassSVG.style.transform = `rotate(${-euler.y}rad)`;

        }

        cityMat.opacity += (targetCityOpacity - cityMat.opacity) * 0.08;
        countryMat.opacity += (targetCountryOpacity - countryMat.opacity) * 0.08;



        renderer.render(scene,camera);
        }

      animate();
    }

    class GeoBoundaryLayer {

      constructor(scene, radius) {
        this.scene = scene;
        this.radius = radius;
        this.group = new THREE.Group();
        this.scene.add(this.group);
      }

      latLonToVector3(lat, lon, altitude = 0.01) {

        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);

        const r = this.radius + altitude;

        const x = -r * Math.sin(phi) * Math.cos(theta);
        const z =  r * Math.sin(phi) * Math.sin(theta);
        const y =  r * Math.cos(phi);

        return new THREE.Vector3(x, y, z);
      }

      loadGeoJSON(geojson) {

        geojson.features.forEach(feature => {

          const geometry = feature.geometry;

          if (geometry.type === "Polygon") {
            this.drawPolygon(geometry.coordinates);
          }

          if (geometry.type === "MultiPolygon") {
            geometry.coordinates.forEach(polygon => {
              this.drawPolygon(polygon);
            });
          }

        });
      }

    drawPolygon(polygon) {

      polygon.forEach(ring => {

        const points = [];

        ring.forEach(coord => {
          const [lon, lat] = coord;
          points.push(this.latLonToVector3(lat, lon));
        });

        const geometry = new THREE.BufferGeometry().setFromPoints(points);

        const material = new THREE.ShaderMaterial({
          transparent: true,
          uniforms: {
            color: { value: new THREE.Color(1.5, 1.5, 1.5) },
            opacity: { value: 0.99 }
          },
          vertexShader: `
            varying float vDot;

            void main() {

              vec4 worldPosition = modelMatrix * vec4(position, 1.0);
              vec3 normal = normalize(worldPosition.xyz);

              vec3 cameraDir = normalize(cameraPosition - worldPosition.xyz);

              vDot = dot(normal, cameraDir);

              gl_Position = projectionMatrix * viewMatrix * worldPosition;
            }
          `,
          fragmentShader: `
            uniform vec3 color;
            uniform float opacity;
            varying float vDot;

            void main() {

              float shade = clamp(vDot, 0.0, 1.0);

              // Softer edge falloff
              float contrast = pow(shade, 1.3);

              // Darkness level for far side (unchanged)
              float darkness = 0.12;

              // Lift brightness slightly near the globe edge
              float edgeLift = smoothstep(0.0, 0.25, shade) * 0.15;

              float finalShade = mix(darkness, 1.0, contrast);
              finalShade += edgeLift;

              gl_FragColor = vec4(color * finalShade, opacity * finalShade);
            }

          `
        });


        const line = new THREE.Line(geometry, material);
        this.group.add(line);

      });
    }


    setVisible(value) {
      this.group.visible = value;
    }

    setColor(color) {
      this.group.children.forEach(child => {
        child.material.uniforms.color.value.set(color);
      });
    }

  }



  </script>
</body>
</html>